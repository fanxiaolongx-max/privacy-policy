<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF 编辑器 Pro Ultra (增强版)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">

    <style>
        body { background-color: #f8fafc; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
        .tool-btn { 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 52px; height: 52px; border-radius: 10px; color: #64748b; transition: all 0.2s; position: relative;
        }
        .tool-btn:hover { background-color: #f1f5f9; color: #0f172a; }
        .tool-btn.active { background-color: #eff6ff; color: #2563eb; }
        .tool-btn.active::after { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 3px; height: 20px; background: #2563eb; border-radius: 0 4px 4px 0; }
        .tool-btn i { font-size: 1.4rem; margin-bottom: 2px; }
        .tool-label { font-size: 0.6rem; font-weight: 600; transform: scale(0.9); }
        #main-area {
            background-color: #e2e8f0;
            background-image: linear-gradient(45deg, #cbd5e1 25%, transparent 25%, transparent 75%, #cbd5e1 75%, #cbd5e1), linear-gradient(45deg, #cbd5e1 25%, transparent 25%, transparent 75%, #cbd5e1 75%, #cbd5e1);
            background-size: 20px 20px; background-position: 0 0, 10px 10px;
        }
        #canvas-wrapper { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); margin: 40px auto; background: white; transition: transform 0.1s ease-out; position: relative; }
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 5px; border: 2px solid #e2e8f0; }
        ::-webkit-scrollbar-track { background: #e2e8f0; }
        .color-grid-btn { width: 24px; height: 24px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.1s; }
        .color-grid-btn:hover { transform: scale(1.2); z-index: 10; border-color: #94a3b8; }
        /* Grid Overlay styling */
        .grid-overlay {
            background-size: 50px 50px;
            background-image:
                linear-gradient(to right, rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
            pointer-events: none;
        }
        /* === 修复点击画布时的抖动/缩小问题 === */
        .canvas-container, canvas {
            outline: none !important; /* 移除蓝色聚焦边框 */
            -webkit-tap-highlight-color: transparent; /* 移除移动端点击高亮 */
        }
        
        /* 确保画布容器不会因为边框而溢出 */
        #canvas-wrapper {
            outline: none;
            border: none;
        }
    </style>
</head>
<body class="flex flex-col h-screen text-slate-800 select-none">

    <div class="h-14 bg-white border-b flex items-center justify-between px-4 shadow-sm z-30">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-lg flex items-center justify-center text-white font-bold shadow-md"><i class="ri-edit-box-line"></i></div>
            <div><h1 class="font-bold text-slate-800 text-base">PDF Editor <span class="text-blue-600">Pro</span></h1></div>
            <div class="ml-6 flex items-center bg-slate-100 rounded-lg p-1 gap-1">
                <button onclick="undo()" id="btn-undo" class="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm text-slate-500 disabled:opacity-30 disabled:cursor-not-allowed" disabled><i class="ri-arrow-go-back-line"></i></button>
                <button onclick="redo()" id="btn-redo" class="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm text-slate-500 disabled:opacity-30 disabled:cursor-not-allowed" disabled><i class="ri-arrow-go-forward-line"></i></button>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <span id="file-name" class="text-xs text-slate-400 font-mono hidden md:block max-w-[200px] truncate"></span>
            
            <input type="file" id="file-upload" accept="application/pdf" class="hidden">

            <button onclick="document.getElementById('file-upload').click()" class="px-3 py-1.5 rounded-md text-sm font-medium text-slate-600 hover:bg-slate-100 transition-all flex items-center gap-2">
                <i class="ri-folder-open-line"></i> 打开 PDF
            </button>
            
            <button onclick="openProject()" class="px-3 py-1.5 rounded-md text-sm font-medium text-slate-600 hover:bg-slate-100 transition-all flex items-center gap-2">
                <i class="ri-file-code-line"></i> 导入工程
            </button>
            
            <div class="w-px h-4 bg-slate-300 mx-1"></div>
            
            <button onclick="saveProject()" class="px-3 py-1.5 rounded-md text-sm font-medium text-slate-600 hover:bg-slate-100 transition-all flex items-center gap-2">
                <i class="ri-save-2-line"></i> 保存工程
            </button>

            <button onclick="savePDF()" id="btn-save" class="bg-blue-600 hover:bg-blue-700 text-white px-5 py-1.5 rounded-md text-sm font-medium flex items-center gap-2 shadow-md shadow-blue-200 transition-all opacity-50 cursor-not-allowed" disabled>
                <i class="ri-save-3-line"></i> 导出 PDF
            </button>
        </div>
    </div>

    <div class="flex flex-1 overflow-hidden">
        <div class="w-20 bg-white border-r flex flex-col items-center py-4 gap-2 z-20 shadow-sm">
            <button class="tool-btn active" id="tool-select" onclick="setTool('select')" title="选择工具 (V)"><i class="ri-cursor-line"></i><span class="tool-label">选择</span></button>
            <div class="w-8 h-px bg-slate-100 my-1"></div>
            <button class="tool-btn" id="tool-text" onclick="addText()" title="添加文本 (T)"><i class="ri-text"></i><span class="tool-label">文本</span></button>
            <button class="tool-btn" id="tool-whiteout" onclick="setTool('whiteout')" title="矩形遮盖"><i class="ri-shape-fill"></i><span class="tool-label">遮盖</span></button>
            <button class="tool-btn" id="tool-draw" onclick="setTool('draw')" title="自由绘图 (P)"><i class="ri-pencil-fill"></i><span class="tool-label">画笔</span></button>
            <button class="tool-btn" id="tool-highlight" onclick="setTool('highlight')" title="高亮笔"><i class="ri-mark-pen-fill"></i><span class="tool-label">高亮</span></button>
            <button class="tool-btn" onclick="document.getElementById('img-upload').click()" title="插入图片"><i class="ri-image-add-line"></i><span class="tool-label">图片</span></button>
            <input type="file" id="img-upload" accept="image/*" class="hidden">
            
            <div class="mt-auto flex flex-col gap-2 mb-2">
                <button class="tool-btn text-slate-400 hover:text-blue-600" onclick="toggleGrid()" title="辅助网格"><i class="ri-grid-line"></i></button>
                <div class="w-8 h-px bg-slate-100 my-1"></div>
                <button class="tool-btn text-slate-400 hover:text-blue-600" onclick="copyObject()" title="复制"><i class="ri-file-copy-line"></i></button>
                <button class="tool-btn text-slate-400 hover:text-red-500" onclick="deleteActiveObject()" title="删除选中"><i class="ri-delete-bin-line"></i></button>
            </div>
        </div>

        <div class="flex-1 relative overflow-hidden flex flex-col" id="main-area-container">
            <div class="flex-1 relative overflow-auto flex justify-center p-8 custom-scroll" id="main-scroll">
                <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center text-slate-400 pointer-events-none">
                    <div class="bg-white p-10 rounded-2xl shadow-sm border border-slate-200 flex flex-col items-center">
                        <div class="w-20 h-20 bg-blue-50 rounded-full flex items-center justify-center mb-4"><i class="ri-upload-cloud-2-line text-4xl text-blue-500"></i></div>
                        <p class="font-bold text-slate-700 text-lg">上传 PDF 开始编辑</p>
                    </div>
                </div>
                <div id="canvas-wrapper" class="hidden origin-top center">
                    <canvas id="fabric-canvas"></canvas>
                    <div id="grid-layer" class="absolute inset-0 grid-overlay hidden z-0"></div>
                </div>
            </div>

            <div id="bottom-bar" class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-white/95 backdrop-blur shadow-xl border border-slate-200 rounded-full px-4 py-2 flex items-center gap-3 z-40 hidden transition-all">
                <div class="flex items-center gap-2 pr-4 border-r border-slate-200">
                    <button onclick="rotatePage(-90)" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600" title="向左旋转"><i class="ri-anticlockwise-2-line"></i></button>
                    <button onclick="rotatePage(90)" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600" title="向右旋转"><i class="ri-clockwise-2-line"></i></button>
                    <button onclick="clearPage()" class="w-8 h-8 rounded-full hover:bg-red-50 text-red-500" title="清空本页"><i class="ri-eraser-line"></i></button>
                </div>

                <div class="flex items-center gap-1 pr-4 border-r border-slate-200">
                    <button onclick="changePage(-1)" class="w-8 h-8 rounded-full hover:bg-slate-100 flex items-center justify-center text-slate-600 transition"><i class="ri-arrow-left-s-line text-lg"></i></button>
                    <span class="text-xs font-bold font-mono text-slate-700 min-w-[3.5rem] text-center"><span id="page-num">0</span> / <span id="page-count">0</span></span>
                    <button onclick="changePage(1)" class="w-8 h-8 rounded-full hover:bg-slate-100 flex items-center justify-center text-slate-600 transition"><i class="ri-arrow-right-s-line text-lg"></i></button>
                </div>
                <div class="flex items-center gap-1 pl-1">
                    <button onclick="setZoom(-0.1)" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600"><i class="ri-subtract-line"></i></button>
                    <span id="zoom-val" class="text-xs font-mono font-bold text-slate-700 w-12 text-center">100%</span>
                    <button onclick="setZoom(0.1)" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600"><i class="ri-add-line"></i></button>
                    <button onclick="resetZoom()" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600" title="适应宽度"><i class="ri-aspect-ratio-line"></i></button>
                </div>
            </div>
        </div>

        <div class="w-72 bg-white border-l flex flex-col z-20 transition-all" id="right-panel">
            <div class="px-5 py-4 border-b flex justify-between items-center">
                <h2 class="text-xs font-bold text-slate-500 uppercase tracking-widest">属性设置</h2>
                <span id="selection-tag" class="text-[10px] bg-slate-100 text-slate-500 px-2 py-0.5 rounded-full hidden">OBJECT</span>
            </div>
            
            <div id="properties-content" class="p-5 space-y-6 overflow-y-auto flex-1 opacity-50 pointer-events-none transition-opacity duration-200">
                <div id="font-section" class="hidden">
                    <label class="text-xs font-semibold text-slate-500 mb-2 block">字体 / Font</label>
                    <select id="prop-font" class="w-full border border-slate-200 rounded-lg px-2 py-1.5 text-sm bg-white focus:ring-2 focus:ring-blue-100 outline-none" onchange="updateActiveObject('font')">
                        <option value="sans-serif">系统默认 (Sans-serif)</option>
                        <option value="SimSun">宋体 (SimSun)</option>
                        <option value="Microsoft YaHei">微软雅黑 (YaHei)</option>
                        <option value="KaiTi">楷体 (KaiTi)</option>
                        <option value="SimHei">黑体 (SimHei)</option>
                        <option value="Arial">Arial</option>
                    </select>
                </div>

                <div>
                    <div class="flex justify-between mb-2">
                        <label class="text-xs font-semibold text-slate-500">颜色</label>
                        <div class="flex items-center gap-2 border rounded px-2 py-0.5 cursor-pointer hover:bg-slate-50" onclick="document.getElementById('prop-color').click()">
                            <div id="color-preview" class="w-3 h-3 rounded-full bg-black border"></div>
                            <span id="color-hex" class="text-xs font-mono text-slate-500">#000000</span>
                            <input type="color" id="prop-color" class="hidden" oninput="updateActiveObject('color')">
                        </div>
                    </div>
                    <div class="grid grid-cols-6 gap-2">
                        <div class="color-grid-btn bg-black" onclick="setColor('#000000')"></div>
                        <div class="color-grid-btn bg-gray-500" onclick="setColor('#6b7280')"></div>
                        <div class="color-grid-btn bg-red-500" onclick="setColor('#ef4444')"></div>
                        <div class="color-grid-btn bg-orange-500" onclick="setColor('#f97316')"></div>
                        <div class="color-grid-btn bg-yellow-500" onclick="setColor('#eab308')"></div>
                        <div class="color-grid-btn bg-green-500" onclick="setColor('#22c55e')"></div>
                        <div class="color-grid-btn bg-blue-500" onclick="setColor('#3b82f6')"></div>
                        <div class="color-grid-btn bg-indigo-500" onclick="setColor('#6366f1')"></div>
                        <div class="color-grid-btn bg-purple-500" onclick="setColor('#a855f7')"></div>
                        <div class="color-grid-btn bg-pink-500" onclick="setColor('#ec4899')"></div>
                        <div class="color-grid-btn bg-white" onclick="setColor('#ffffff')"></div>
                    </div>
                </div>

                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs font-semibold text-slate-500" id="size-label">大小</label>
                            <span class="text-xs font-mono text-slate-600" id="size-val">20</span>
                        </div>
                        <input type="range" id="prop-size" min="1" max="120" value="20" class="w-full accent-blue-600 h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer" oninput="updateActiveObject('size')">
                    </div>
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs font-semibold text-slate-500">透明度</label>
                            <span class="text-xs font-mono text-slate-600" id="opacity-val">100%</span>
                        </div>
                        <input type="range" id="prop-opacity" min="0" max="1" step="0.1" value="1" class="w-full accent-blue-600 h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer" oninput="updateActiveObject('opacity')">
                    </div>
                </div>

                <div id="text-styles" class="hidden">
                    <label class="text-xs font-semibold text-slate-500 mb-2 block">样式</label>
                    <div class="flex bg-slate-100 p-1 rounded-lg">
                        <button onclick="toggleBold()" class="flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm font-bold transition" id="btn-bold">B</button>
                        <button onclick="toggleItalic()" class="flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm italic transition" id="btn-italic">I</button>
                        <button onclick="toggleLinethrough()" class="flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm line-through transition" id="btn-strike">S</button>
                    </div>
                </div>

                <div class="pt-4 border-t border-slate-100">
                    <label class="text-xs font-semibold text-slate-500 mb-2 block">操作</label>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="canvas.bringForward(canvas.getActiveObject())" class="px-2 py-1.5 bg-white border rounded text-xs hover:bg-slate-50 text-slate-600">上移一层</button>
                        <button onclick="canvas.sendBackwards(canvas.getActiveObject())" class="px-2 py-1.5 bg-white border rounded text-xs hover:bg-slate-50 text-slate-600">下移一层</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="loader" class="fixed inset-0 bg-white/90 backdrop-blur-md z-50 hidden flex items-center justify-center flex-col">
        <div class="spinner border-blue-600 w-12 h-12 border-4 rounded-full border-t-transparent animate-spin"></div>
        <p class="mt-6 text-slate-600 font-medium" id="loader-text">处理中...</p>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        const { PDFDocument, degrees } = PDFLib;

        let pdfDoc = null, currentPage = 1, canvas = null, fileBytes = null;
        let pageObjects = {}; 
        let pageRotations = {}; // 存储页面旋转状态 { pageNum: angle }
        let currentZoom = 1.0, canvasBaseWidth = 0;
        const history = { undo: [], redo: [], locked: false };
        let showGrid = false;

        function initCanvas() {
            canvas = new fabric.Canvas('fabric-canvas', { 
                preserveObjectStacking: true, 
                selection: true,
                // === 新增配置：禁止自动滚动 ===
                fireRightClick: true,  // 某些浏览器需要这个来阻止默认行为
                stopContextMenu: true, 
            });
            canvas.on('selection:created', onSelect);
            canvas.on('selection:updated', onSelect);
            canvas.on('selection:cleared', onClear);
            canvas.on('object:added', () => saveHistory('add'));
            canvas.on('object:modified', () => saveHistory('mod'));
            canvas.on('object:removed', () => saveHistory('rem'));
            canvas.on('mouse:down', function(e) {
                // 如果是在文字编辑模式，不要拦截，否则没法输入
                if (canvas.getActiveObject() && canvas.getActiveObject().isEditing) return;
                
                // 阻止默认的聚焦滚动行为
                if (e.e) {
                    e.e.preventDefault();
                    e.e.stopPropagation();
                }
            });
        }

        // 文件加载
        document.getElementById('file-upload').onchange = async (e) => {
            const f = e.target.files[0]; if(!f) return;
            showLoader(true, '解析 PDF...');
            try {
                fileBytes = await f.arrayBuffer();
                document.getElementById('file-name').innerText = f.name;
                pdfDoc = await pdfjsLib.getDocument({
                  data: fileBytes.slice(0),
                  cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                  cMapPacked: true,
                  standardFontDataUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/',
                }).promise;

                document.getElementById('page-count').innerText = pdfDoc.numPages;
                document.getElementById('empty-state').classList.add('hidden');
                document.getElementById('canvas-wrapper').classList.remove('hidden');
                document.getElementById('bottom-bar').classList.remove('hidden');
                document.getElementById('btn-save').disabled = false;
                document.getElementById('btn-save').classList.remove('opacity-50', 'cursor-not-allowed');
                if(!canvas) initCanvas();
                pageObjects = {}; pageRotations = {}; 
                history.undo = []; history.redo = []; currentPage = 1;
                await renderPage(1); resetZoom();
            } catch(err) { alert('错误: ' + err.message); } finally { showLoader(false); }
        };

        function stashCurrentObjects() {
            // === 修复开始 ===
            // 1. 在保存之前，必须取消所有选中状态！
            // 这会将对象从临时选区中释放出来，恢复正确的绝对坐标 (left, top)
            canvas.discardActiveObject(); 
            
            // 2. 强制刷新一下，确保坐标更新完成
            canvas.requestRenderAll(); 
            // === 修复结束 ===

            const objs = canvas.getObjects();
            if(objs.length > 0) pageObjects[currentPage] = objs.map(o => o.toObject());
            else delete pageObjects[currentPage];
        }

        async function renderPage(num) {
            showLoader(true, `加载第 ${num} 页...`);
            try {
                const page = await pdfDoc.getPage(num);
                // 获取旋转角度
                const userRotation = pageRotations[num] || 0;
                const totalRotation = (page.rotate + userRotation) % 360;
                
                const viewport = page.getViewport({scale: 2.0, rotation: totalRotation});
                const tempCvs = document.createElement('canvas');
                tempCvs.width = viewport.width; tempCvs.height = viewport.height;
                
                await page.render({canvasContext: tempCvs.getContext('2d'), viewport}).promise;
                
                const bgURL = tempCvs.toDataURL('image/jpeg', 0.8);
                canvasBaseWidth = viewport.width;
                canvas.setWidth(viewport.width); canvas.setHeight(viewport.height);
                canvas.clear(); 
                history.undo = []; history.redo = []; updateHistoryBtns(); 

                fabric.Image.fromURL(bgURL, (img) => {
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { 
                        originX: 'left', originY: 'top', scaleX: 1, scaleY: 1, erasable: false 
                    });
                    
                    if(pageObjects[num]) {
                        history.locked = true;
                        fabric.util.enlivenObjects(pageObjects[num], (objs) => { 
                            objs.forEach(o => canvas.add(o)); 
                            canvas.renderAll(); 
                            history.locked = false; 
                        });
                    }
                    document.getElementById('page-num').innerText = num;
                    applyZoom(); showLoader(false);
                });
            } catch(e) { console.error(e); showLoader(false); }
        }

        // --- Pro Ultra Features: Rotation & Grid ---

        window.rotatePage = async (angle) => {
            stashCurrentObjects();
            const current = pageRotations[currentPage] || 0;
            // 确保角度在 0-360 之间
            let next = (current + angle) % 360;
            if (next < 0) next += 360;
            pageRotations[currentPage] = next;
            await renderPage(currentPage);
        };

        window.clearPage = () => {
            if(confirm('确定要清空当前页面的所有标注吗？(此操作不可撤销)')) {
                canvas.clear();
                // 重新设置背景图因为 clear 会清除背景
                renderPage(currentPage);
            }
        };

        window.toggleGrid = () => {
            showGrid = !showGrid;
            const grid = document.getElementById('grid-layer');
            if(showGrid) grid.classList.remove('hidden');
            else grid.classList.add('hidden');
        };

        // ------------------------------------------

        window.changePage = async (d) => { const next = currentPage + d; if(next < 1 || next > pdfDoc.numPages) return; stashCurrentObjects(); currentPage = next; await renderPage(currentPage); };
        window.setZoom = (d) => { currentZoom = Math.max(0.2, Math.min(3.0, currentZoom + d)); applyZoom(); };
        window.resetZoom = () => { const containerW = document.getElementById('main-scroll').clientWidth - 64; currentZoom = containerW / canvasBaseWidth; applyZoom(); };
        function applyZoom() { document.getElementById('zoom-val').innerText = Math.round(currentZoom * 100) + '%'; document.getElementById('canvas-wrapper').style.transform = `scale(${currentZoom})`; }

        // === 工具与属性 ===
        function activatePanel(type) {
            const p = document.getElementById('properties-content');
            p.classList.remove('opacity-50', 'pointer-events-none');
            const tag = document.getElementById('selection-tag');
            tag.innerText = type.toUpperCase();
            tag.classList.remove('hidden');
            
            if(type === 'text' || type === 'i-text') {
                document.getElementById('font-section').classList.remove('hidden');
                document.getElementById('text-styles').classList.remove('hidden');
                document.getElementById('size-label').innerText = '字号';
            } else {
                document.getElementById('font-section').classList.add('hidden');
                document.getElementById('text-styles').classList.add('hidden');
                document.getElementById('size-label').innerText = (type === 'path' || type === 'brush') ? '笔触粗细' : '大小';
            }
        }

        window.setTool = (mode) => {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById(`tool-${mode}`);
            if(btn) btn.classList.add('active');

            canvas.isDrawingMode = false;
            canvas.selection = true;
            canvas.defaultCursor = 'default';
            canvas.discardActiveObject();
            canvas.requestRenderAll();

            if(mode === 'draw' || mode === 'highlight') {
                canvas.isDrawingMode = true;
                const brush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush = brush;
                activatePanel('brush'); 
                
                const color = document.getElementById('prop-color').value;
                const size = parseInt(document.getElementById('prop-size').value);
                const opacity = parseFloat(document.getElementById('prop-opacity').value);
                brush.width = size || 5;
                if(mode === 'highlight') {
                    brush.color = "rgba(255, 235, 59, 0.5)"; 
                    brush.width = 30;
                } else {
                    brush.color = hexToRgba(color, opacity);
                }
            } else if (mode === 'whiteout') {
                const rect = new fabric.Rect({ left: canvas.width/2 - 100, top: canvas.height/2 - 50, width: 200, height: 100, fill: 'white', stroke: '#e2e8f0', strokeWidth: 1 });
                canvas.add(rect); canvas.setActiveObject(rect); setTool('select');
            } else {
                if(!canvas.getActiveObject()) onClear();
            }
        };

        window.addText = () => {
            // === 1. 核级锁定：直接冻结容器的滚动能力 ===
            const scrollContainer = document.getElementById('main-scroll');
            
            // 记录当前的滚动位置
            const savedScrollTop = scrollContainer.scrollTop;
            const savedScrollLeft = scrollContainer.scrollLeft;
            
            // 临时将 overflow 设置为 hidden，物理上禁止滚动条移动
            // 这会强制浏览器无法执行“聚焦跳转”
            scrollContainer.style.overflow = 'hidden';

            // 防止按钮本身的焦点干扰
            if(document.activeElement) document.activeElement.blur();

            setTool('text');
            const color = document.getElementById('prop-color').value;
            const fontSize = 40 / currentZoom; 
            
            // 放在可视区域的中心，而不是画布的绝对中心
            // 这样能确保文字一定出现在用户眼前，而不是跳到画布很远的地方
            // 获取 canvas 容器在视口中的位置
            const wrapper = document.getElementById('canvas-wrapper');
            const wrapperRect = wrapper.getBoundingClientRect();
            const containerRect = scrollContainer.getBoundingClientRect();
            
            // 计算相对于 Canvas 的中心点
            // (容器中心 - 画布左上角) / 缩放比例
            let targetLeft = (containerRect.width / 2 - wrapperRect.left) / currentZoom;
            let targetTop = (containerRect.height / 2 - wrapperRect.top) / currentZoom;
            
            // 边界检查：不要让字跑出画布
            targetLeft = Math.max(20, Math.min(canvas.width - 20, targetLeft));
            targetTop = Math.max(20, Math.min(canvas.height - 20, targetTop));

            const text = new fabric.IText('双击输入', { 
                left: targetLeft, 
                top: targetTop, 
                fill: color, 
                fontSize: fontSize, 
                fontFamily: 'sans-serif',
                originX: 'center',
                originY: 'center'
            });

            canvas.add(text);
            canvas.setActiveObject(text);
            
            // === 2. 执行聚焦操作 ===
            // 此时容器是 overflow: hidden 的，浏览器想跳也跳不了
            text.enterEditing();
            text.selectAll();

            // === 3. 解除锁定 ===
            // 稍微延迟一点点，等浏览器放弃跳转念头后，再恢复滚动条
            setTimeout(() => {
                // 恢复原有的滚动状态
                scrollContainer.style.overflow = 'auto';
                
                // 双重保险：再次强制写回原来的位置
                scrollContainer.scrollTop = savedScrollTop;
                scrollContainer.scrollLeft = savedScrollLeft;
            }, 50); // 50毫秒足够让浏览器完成聚焦渲染
        };

        document.getElementById('img-upload').onchange = (e) => {
            const f = e.target.files[0]; if(!f) return;
            const r = new FileReader();
            r.onload = (res) => {
                fabric.Image.fromURL(res.target.result, (img) => {
                    img.scaleToWidth(200); img.set({left: canvas.width/2-100, top: canvas.height/2-100});
                    canvas.add(img); canvas.setActiveObject(img);
                });
            };
            r.readAsDataURL(f); e.target.value = '';
        };

        function onSelect() {
            const obj = canvas.getActiveObject(); if(!obj) return;
            activatePanel(obj.type);
            if(obj.fill && typeof obj.fill === 'string' && obj.fill.startsWith('#')) {
                document.getElementById('prop-color').value = obj.fill;
                document.getElementById('color-hex').innerText = obj.fill;
                document.getElementById('color-preview').style.backgroundColor = obj.fill;
            }
            if(obj.type === 'i-text') {
                document.getElementById('prop-font').value = obj.fontFamily || 'sans-serif';
                document.getElementById('prop-size').value = obj.fontSize;
                document.getElementById('size-val').innerText = obj.fontSize;
                document.getElementById('btn-bold').className = obj.fontWeight==='bold' ? 'flex-1 py-1.5 rounded bg-blue-100 text-blue-600 text-sm font-bold transition' : 'flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm font-bold transition';
                document.getElementById('btn-italic').className = obj.fontStyle==='italic' ? 'flex-1 py-1.5 rounded bg-blue-100 text-blue-600 text-sm italic transition' : 'flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm italic transition';
                document.getElementById('btn-strike').className = obj.linethrough ? 'flex-1 py-1.5 rounded bg-blue-100 text-blue-600 text-sm line-through transition' : 'flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm line-through transition';
            } else if (obj.type === 'path') {
                document.getElementById('prop-size').value = obj.strokeWidth;
                document.getElementById('size-val').innerText = obj.strokeWidth.toFixed(0);
            }
            document.getElementById('prop-opacity').value = obj.opacity;
            document.getElementById('opacity-val').innerText = Math.round(obj.opacity*100) + '%';
        }

        function onClear() {
            if(canvas.isDrawingMode) return;
            document.getElementById('properties-content').classList.add('opacity-50', 'pointer-events-none');
            document.getElementById('selection-tag').classList.add('hidden');
        }

        window.updateActiveObject = (key, val) => {
            const obj = canvas.getActiveObject();
            if(val === undefined) {
                if(key === 'color') val = document.getElementById('prop-color').value;
                if(key === 'size') val = parseInt(document.getElementById('prop-size').value);
                if(key === 'opacity') val = parseFloat(document.getElementById('prop-opacity').value);
                if(key === 'font') val = document.getElementById('prop-font').value;
            }
            if(key === 'color') { document.getElementById('color-hex').innerText = val; document.getElementById('color-preview').style.backgroundColor = val; }
            if(key === 'size') document.getElementById('size-val').innerText = val;
            if(key === 'opacity') document.getElementById('opacity-val').innerText = Math.round(val*100)+'%';

            if(obj) {
                if(key === 'color') { if(obj.type === 'i-text' || obj.type === 'rect') obj.set('fill', val); if(obj.type === 'path') obj.set('stroke', val); }
                if(key === 'size') { if(obj.type === 'i-text') obj.set('fontSize', val); else if(obj.type === 'path') obj.set('strokeWidth', val); }
                if(key === 'opacity') obj.set('opacity', val);
                if(key === 'font' && obj.type === 'i-text') obj.set('fontFamily', val);
                canvas.requestRenderAll(); saveHistory('mod');
            }
            if (canvas.isDrawingMode && canvas.freeDrawingBrush) {
                if (key === 'color' || key === 'opacity') {
                    const c = document.getElementById('prop-color').value;
                    const o = parseFloat(document.getElementById('prop-opacity').value);
                    canvas.freeDrawingBrush.color = hexToRgba(c, o);
                }
                if (key === 'size') canvas.freeDrawingBrush.width = parseInt(document.getElementById('prop-size').value);
            }
        };

        window.setColor = (hex) => {
            document.getElementById('prop-color').value = hex === 'transparent' ? '#ffffff' : hex;
            updateActiveObject('color', hex);
        };

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        window.toggleBold = () => { const o=canvas.getActiveObject(); if(o&&o.type==='i-text'){ o.set('fontWeight', o.fontWeight==='bold'?'normal':'bold'); canvas.requestRenderAll(); saveHistory('mod'); onSelect(); }};
        window.toggleItalic = () => { const o=canvas.getActiveObject(); if(o&&o.type==='i-text'){ o.set('fontStyle', o.fontStyle==='italic'?'normal':'italic'); canvas.requestRenderAll(); saveHistory('mod'); onSelect(); }};
        window.toggleLinethrough = () => { const o=canvas.getActiveObject(); if(o&&o.type==='i-text'){ o.set('linethrough', !o.linethrough); canvas.requestRenderAll(); saveHistory('mod'); onSelect(); }};

        function saveHistory(type) {
            if(history.locked) return;
            if(history.undo.length > 20) history.undo.shift();
            history.undo.push(JSON.stringify(canvas.toJSON()));
            history.redo = []; updateHistoryBtns();
        }
        window.undo = () => {
            if(history.undo.length === 0) return;
            history.redo.push(JSON.stringify(canvas.toJSON()));
            const prev = history.undo.pop();
            history.locked = true;
            canvas.loadFromJSON(JSON.parse(prev), () => { canvas.renderAll(); history.locked = false; });
            updateHistoryBtns();
        };
        window.redo = () => {
            if(history.redo.length === 0) return;
            history.undo.push(JSON.stringify(canvas.toJSON()));
            const next = history.redo.pop();
            history.locked = true;
            canvas.loadFromJSON(JSON.parse(next), () => { canvas.renderAll(); history.locked = false; });
            updateHistoryBtns();
        };
        function updateHistoryBtns() {
            document.getElementById('btn-undo').disabled = history.undo.length === 0;
            document.getElementById('btn-redo').disabled = history.redo.length === 0;
            document.getElementById('btn-undo').className = history.undo.length===0 ? 'w-8 h-8 flex items-center justify-center rounded text-slate-300 cursor-not-allowed' : 'w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm text-slate-600';
            document.getElementById('btn-redo').className = history.redo.length===0 ? 'w-8 h-8 flex items-center justify-center rounded text-slate-300 cursor-not-allowed' : 'w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm text-slate-600';
        }

        window.deleteActiveObject = () => { const actives = canvas.getActiveObjects(); if(actives.length) { canvas.discardActiveObject(); actives.forEach(o => canvas.remove(o)); saveHistory('del'); }};
        let _clipboard;
        window.copyObject = () => { const o = canvas.getActiveObject(); if(o) o.clone(c => _clipboard = c); };
        window.pasteObject = () => { if(!_clipboard) return; _clipboard.clone(c => { canvas.discardActiveObject(); c.set({left: c.left+20, top: c.top+20, evented: true}); if(c.type === 'activeSelection') { c.canvas = canvas; c.forEachObject(o => canvas.add(o)); c.setCoords(); } else canvas.add(c); canvas.setActiveObject(c); canvas.requestRenderAll(); saveHistory('paste'); }); };
        window.addEventListener('keydown', (e) => {
            // 1. 获取当前选中的对象
            const activeObj = canvas.getActiveObject();

            // 2. 关键修复：如果当前对象存在，且处于“正在编辑文字”的状态 (isEditing)
            // 则不执行任何自定义快捷键，直接返回，允许浏览器执行默认的文字复制/粘贴行为
            if (activeObj && activeObj.isEditing) {
                return; 
            }

            // --- 原有的逻辑 ---
            // 注意：Delete 的判断逻辑其实也可以简化了，因为上面已经拦截了 isEditing
            if((e.key === 'Delete' || e.key === 'Backspace')) {
                deleteActiveObject();
            }
            
            if((e.ctrlKey||e.metaKey) && e.key === 'c') copyObject();
            if((e.ctrlKey||e.metaKey) && e.key === 'v') pasteObject();
            if((e.ctrlKey||e.metaKey) && e.key === 'z') undo();
            if((e.ctrlKey||e.metaKey) && e.key === 'y') redo();
        });


        // 导出 (终极修正版 v3：完美修复旋转后内容方向错误的问题)
        window.savePDF = async () => {
            stashCurrentObjects(); // 保存当前状态
            showLoader(true, '正在进行坐标系校正与合成...');
            
            try {
                // 1. 加载源文件
                const srcDoc = await PDFDocument.load(fileBytes);
                const pages = srcDoc.getPages();
                const totalPages = srcDoc.getPageCount();
                const { degrees } = PDFLib; // 解构出 degrees 函数工具

                for (let i = 0; i < totalPages; i++) {
                    const pageNum = i + 1;
                    const pdfPage = pages[i];
                    
                    // --- A. 获取原始信息 ---
                    // 关键：在设置新旋转之前，先获取页面最初始的“直立”尺寸
                    const { width: originalWidth, height: originalHeight } = pdfPage.getSize();
                    const currentRotation = pdfPage.getRotation().angle;
                    const userRotation = pageRotations[pageNum] || 0;
                    
                    // 计算最终需要的角度 (0, 90, 180, 270)
                    let finalRotation = (currentRotation + userRotation) % 360;
                    if (finalRotation < 0) finalRotation += 360;
                    
                    // --- B. 设置元数据旋转 ---
                    // 告诉 PDF 阅读器最终应该怎么显示这一页
                    pdfPage.setRotation(degrees(finalRotation));

                    // --- C. 准备标注层图片 ---
                    if (pageObjects[pageNum] && pageObjects[pageNum].length > 0) {
                        
                        // 判断页面是否横过来了
                        const isSideways = finalRotation === 90 || finalRotation === 270;
                        // 计算视觉上的宽高（我们在浏览器里看到的尺寸）
                        const visualWidth = isSideways ? originalHeight : originalWidth;
                        const visualHeight = isSideways ? originalWidth : originalHeight;

                        // 创建临时画布，使用 2倍高清尺寸
                        const staticCvs = new fabric.StaticCanvas(null, { 
                            width: visualWidth * 2, 
                            height: visualHeight * 2
                        });

                        // 恢复对象
                        await new Promise(r => {
                            fabric.util.enlivenObjects(pageObjects[pageNum], (objs) => {
                                objs.forEach(o => staticCvs.add(o));
                                r();
                            });
                        });
                        
                        // 渲染并导出透明 PNG
                        staticCvs.renderAll();
                        const imgData = staticCvs.toDataURL({ format: 'png', multiplier: 1 });
                        const pngImage = await srcDoc.embedPng(imgData);

                        // --- D. 核心修复：计算抵消旋转的绘制参数 ---
                        // PDF 坐标系原点在左下角。我们需要根据旋转角度，把图片“摆正”。
                        
                        let drawOptions = {};

                        switch (finalRotation) {
                            case 0:
                                // 正常直立：直接绘制
                                drawOptions = { x: 0, y: 0, width: visualWidth, height: visualHeight };
                                break;
                                
                            case 90:
                                // 顺时针转了90度。我们需要把图片起点移到右下角，然后自身顺时针转90度摆放。
                                // 注意：此时 visualWidth 其实等于 originalHeight
                                drawOptions = {
                                    x: originalWidth, 
                                    y: 0,
                                    width: visualWidth, 
                                    height: visualHeight,
                                    rotate: degrees(90)
                                };
                                break;
                                
                            case 180:
                                // 颠倒了。移到右上角，自身转180度。
                                drawOptions = {
                                    x: originalWidth,
                                    y: originalHeight,
                                    width: visualWidth,
                                    height: visualHeight,
                                    rotate: degrees(180)
                                };
                                break;
                                
                            case 270:
                                // 顺时针转了270度（相当于逆时针90）。移到左上角，自身转270度。
                                drawOptions = {
                                    x: 0,
                                    y: originalHeight,
                                    width: visualWidth,
                                    height: visualHeight,
                                    rotate: degrees(270)
                                };
                                break;
                        }

                        // 执行绘制
                        pdfPage.drawImage(pngImage, drawOptions);
                    }
                }

                const bytes = await srcDoc.save();
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `edited_fixed_${Date.now()}.pdf`;
                link.click();

            } catch(e) { 
                console.error(e); 
                alert('导出失败: ' + e.message); 
            } finally { 
                showLoader(false); 
            }
        };
        
        function showLoader(show, text) { const l = document.getElementById('loader'); if(show) { l.classList.remove('hidden'); if(text)document.getElementById('loader-text').innerText=text; } else l.classList.add('hidden'); }
        
        // === 2026年1月26日新增项目文件功能
        // === 工具函数：ArrayBuffer 转 Base64 ===
        function bufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // === 工具函数：Base64 转 ArrayBuffer ===
        function base64ToBuffer(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        window.saveProject = () => {
            if (!pdfDoc || !fileBytes) {
                alert('没有打开的文件');
                return;
            }

            // 1. 关键：保存当前页面的最新状态
            // (一定要先 discardActiveObject 防止坐标偏移，复用之前的修复)
            canvas.discardActiveObject(); 
            canvas.requestRenderAll();
            stashCurrentObjects();

            showLoader(true, '正在打包工程文件...');

            // 2. 稍微延迟一下让 UI 渲染 loader
            setTimeout(() => {
                try {
                    // 3. 构建项目数据包
                    const projectData = {
                        version: "1.0",
                        filename: document.getElementById('file-name').innerText,
                        // 将 PDF 二进制转为 Base64 字符串
                        pdfBase64: bufferToBase64(fileBytes), 
                        // 所有页面的标注数据
                        annotations: pageObjects, 
                        // 所有页面的旋转数据
                        rotations: pageRotations 
                    };

                    // 4. 转换为 Blob 并下载
                    const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    // 自定义后缀名为 .pdfpro
                    link.download = `project_${Date.now()}.pdfpro`; 
                    link.click();
                    URL.revokeObjectURL(url);
                } catch (e) {
                    console.error(e);
                    alert('保存失败，文件可能过大');
                } finally {
                    showLoader(false);
                }
            }, 100);
        };

        // 创建一个隐藏的 input 用于上传工程文件
        const projectInput = document.createElement('input');
        projectInput.type = 'file';
        projectInput.accept = '.json,.pdfpro'; // 接受我们自定义的格式
        projectInput.style.display = 'none';
        document.body.appendChild(projectInput);

        // 绑定打开工程文件的逻辑
        window.openProject = () => {
            projectInput.click();
        };

        projectInput.onchange = (e) => {
            const f = e.target.files[0];
            if (!f) return;

            showLoader(true, '正在还原工程...');
            const reader = new FileReader();

            reader.onload = async (res) => {
                try {
                    // 1. 解析 JSON
                    const data = JSON.parse(res.target.result);
                    
                    if (!data.pdfBase64 || !data.annotations) {
                        throw new Error("文件格式不正确");
                    }

                    // 2. 还原 PDF 文件流
                    fileBytes = base64ToBuffer(data.pdfBase64);
                    
                    // 3. 还原标注数据和旋转数据
                    pageObjects = data.annotations;
                    pageRotations = data.rotations || {}; // 兼容旧版本
                    
                    // 4. 重新初始化 PDF.js
                    document.getElementById('file-name').innerText = data.filename || 'Restored Project';
                    pdfDoc = await pdfjsLib.getDocument({
                      data: fileBytes.slice(0),
                      cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/',
                      cMapPacked: true,
                      standardFontDataUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/',
                    }).promise;

                    document.getElementById('page-count').innerText = pdfDoc.numPages;

                    // 5. UI 重置
                    document.getElementById('empty-state').classList.add('hidden');
                    document.getElementById('canvas-wrapper').classList.remove('hidden');
                    document.getElementById('bottom-bar').classList.remove('hidden');
                    document.getElementById('btn-save').disabled = false;
                    document.getElementById('btn-save').classList.remove('opacity-50', 'cursor-not-allowed');

                    if(!canvas) initCanvas();
                    
                    // 6. 渲染第一页
                    history.undo = []; history.redo = []; 
                    currentPage = 1;
                    await renderPage(1);
                    resetZoom();

                } catch (err) {
                    alert('打开失败: ' + err.message);
                    console.error(err);
                } finally {
                    showLoader(false);
                    projectInput.value = ''; // 清空 input 以便下次能选同一个文件
                }
            };
            reader.readAsText(f);
        };

    </script>
</body>
</html>
