<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF 编辑器 Pro Ultra (修复版)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">

    <style>
        body { background-color: #f8fafc; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
        .tool-btn { 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 52px; height: 52px; border-radius: 10px; color: #64748b; transition: all 0.2s; position: relative;
        }
        .tool-btn:hover { background-color: #f1f5f9; color: #0f172a; }
        .tool-btn.active { background-color: #eff6ff; color: #2563eb; }
        .tool-btn.active::after { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 3px; height: 20px; background: #2563eb; border-radius: 0 4px 4px 0; }
        .tool-btn i { font-size: 1.4rem; margin-bottom: 2px; }
        .tool-label { font-size: 0.6rem; font-weight: 600; transform: scale(0.9); }
        #main-area {
            background-color: #e2e8f0;
            background-image: linear-gradient(45deg, #cbd5e1 25%, transparent 25%, transparent 75%, #cbd5e1 75%, #cbd5e1), linear-gradient(45deg, #cbd5e1 25%, transparent 25%, transparent 75%, #cbd5e1 75%, #cbd5e1);
            background-size: 20px 20px; background-position: 0 0, 10px 10px;
        }
        #canvas-wrapper { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); margin: 40px auto; background: white; transition: transform 0.1s ease-out; position: relative; }
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 5px; border: 2px solid #e2e8f0; }
        ::-webkit-scrollbar-track { background: #e2e8f0; }
        .color-grid-btn { width: 24px; height: 24px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.1s; }
        .color-grid-btn:hover { transform: scale(1.2); z-index: 10; border-color: #94a3b8; }
        /* Grid Overlay styling */
        .grid-overlay {
            background-size: 50px 50px;
            background-image:
                linear-gradient(to right, rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
            pointer-events: none;
        }
    </style>
</head>
<body class="flex flex-col h-screen text-slate-800 select-none">

    <div class="h-14 bg-white border-b flex items-center justify-between px-4 shadow-sm z-30">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-lg flex items-center justify-center text-white font-bold shadow-md"><i class="ri-edit-box-line"></i></div>
            <div><h1 class="font-bold text-slate-800 text-base">PDF Editor <span class="text-blue-600">Pro</span></h1></div>
            <div class="ml-6 flex items-center bg-slate-100 rounded-lg p-1 gap-1">
                <button onclick="undo()" id="btn-undo" class="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm text-slate-500 disabled:opacity-30 disabled:cursor-not-allowed" disabled><i class="ri-arrow-go-back-line"></i></button>
                <button onclick="redo()" id="btn-redo" class="w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm text-slate-500 disabled:opacity-30 disabled:cursor-not-allowed" disabled><i class="ri-arrow-go-forward-line"></i></button>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <span id="file-name" class="text-xs text-slate-400 font-mono hidden md:block max-w-[200px] truncate"></span>
            <input type="file" id="file-upload" accept="application/pdf" class="hidden">
            <button onclick="document.getElementById('file-upload').click()" class="px-3 py-1.5 rounded-md text-sm font-medium text-slate-600 hover:bg-slate-100 border border-transparent transition-all flex items-center gap-2"><i class="ri-folder-open-line"></i> 打开</button>
            <button onclick="savePDF()" id="btn-save" class="bg-blue-600 hover:bg-blue-700 text-white px-5 py-1.5 rounded-md text-sm font-medium flex items-center gap-2 shadow-md shadow-blue-200 transition-all opacity-50 cursor-not-allowed" disabled><i class="ri-save-3-line"></i> 导出</button>
        </div>
    </div>

    <div class="flex flex-1 overflow-hidden">
        <div class="w-20 bg-white border-r flex flex-col items-center py-4 gap-2 z-20 shadow-sm">
            <button class="tool-btn active" id="tool-select" onclick="setTool('select')" title="选择工具 (V)"><i class="ri-cursor-line"></i><span class="tool-label">选择</span></button>
            <div class="w-8 h-px bg-slate-100 my-1"></div>
            <button class="tool-btn" id="tool-text" onclick="addText()" title="添加文本 (T)"><i class="ri-text"></i><span class="tool-label">文本</span></button>
            <button class="tool-btn" id="tool-whiteout" onclick="setTool('whiteout')" title="矩形遮盖"><i class="ri-shape-fill"></i><span class="tool-label">遮盖</span></button>
            <button class="tool-btn" id="tool-draw" onclick="setTool('draw')" title="自由绘图 (P)"><i class="ri-pencil-fill"></i><span class="tool-label">画笔</span></button>
            <button class="tool-btn" id="tool-highlight" onclick="setTool('highlight')" title="高亮笔"><i class="ri-mark-pen-fill"></i><span class="tool-label">高亮</span></button>
            <button class="tool-btn" onclick="document.getElementById('img-upload').click()" title="插入图片"><i class="ri-image-add-line"></i><span class="tool-label">图片</span></button>
            
            <button class="tool-btn" id="tool-rect" onclick="setTool('rect')" title="矩形">
                <i class="ri-checkbox-blank-line"></i>
                <span class="tool-label">矩形</span>
            </button>

            <button class="tool-btn" id="tool-circle" onclick="setTool('circle')" title="圆形">
                <i class="ri-checkbox-blank-circle-line"></i>
                <span class="tool-label">圆形</span>
            </button>



            
            <input type="file" id="img-upload" accept="image/*" class="hidden">
            
            <div class="mt-auto flex flex-col gap-2 mb-2">
                <button class="tool-btn text-slate-400 hover:text-blue-600" onclick="toggleGrid()" title="辅助网格"><i class="ri-grid-line"></i></button>
                <div class="w-8 h-px bg-slate-100 my-1"></div>
                <button class="tool-btn text-slate-400 hover:text-blue-600" onclick="copyObject()" title="复制"><i class="ri-file-copy-line"></i></button>
                <button class="tool-btn text-slate-400 hover:text-red-500" onclick="deleteActiveObject()" title="删除选中"><i class="ri-delete-bin-line"></i></button>
            </div>
        </div>

        <div class="flex-1 relative overflow-hidden flex flex-col" id="main-area-container">
            <div class="flex-1 relative overflow-auto flex justify-center p-8 custom-scroll" id="main-scroll">
                <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center text-slate-400 pointer-events-none">
                    <div class="bg-white p-10 rounded-2xl shadow-sm border border-slate-200 flex flex-col items-center">
                        <div class="w-20 h-20 bg-blue-50 rounded-full flex items-center justify-center mb-4"><i class="ri-upload-cloud-2-line text-4xl text-blue-500"></i></div>
                        <p class="font-bold text-slate-700 text-lg">上传 PDF 开始编辑</p>
                    </div>
                </div>
                <div id="canvas-wrapper" class="hidden origin-top center">
                    <canvas id="fabric-canvas"></canvas>
                    <div id="grid-layer" class="absolute inset-0 grid-overlay hidden z-0"></div>
                </div>
            </div>

            <div id="bottom-bar" class="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-white/95 backdrop-blur shadow-xl border border-slate-200 rounded-full px-4 py-2 flex items-center gap-3 z-40 hidden transition-all">
                <div class="flex items-center gap-2 pr-4 border-r border-slate-200">
                    <button onclick="rotatePage(-90)" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600" title="向左旋转"><i class="ri-anticlockwise-2-line"></i></button>
                    <button onclick="rotatePage(90)" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600" title="向右旋转"><i class="ri-clockwise-2-line"></i></button>
                    <button onclick="clearPage()" class="w-8 h-8 rounded-full hover:bg-red-50 text-red-500" title="清空本页"><i class="ri-eraser-line"></i></button>
                </div>

                <div class="flex items-center gap-1 pr-4 border-r border-slate-200">
                    <button onclick="changePage(-1)" class="w-8 h-8 rounded-full hover:bg-slate-100 flex items-center justify-center text-slate-600 transition"><i class="ri-arrow-left-s-line text-lg"></i></button>
                    <span class="text-xs font-bold font-mono text-slate-700 min-w-[3.5rem] text-center"><span id="page-num">0</span> / <span id="page-count">0</span></span>
                    <button onclick="changePage(1)" class="w-8 h-8 rounded-full hover:bg-slate-100 flex items-center justify-center text-slate-600 transition"><i class="ri-arrow-right-s-line text-lg"></i></button>
                </div>
                <div class="flex items-center gap-1 pl-1">
                    <button onclick="setZoom(-0.1)" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600"><i class="ri-subtract-line"></i></button>
                    <span id="zoom-val" class="text-xs font-mono font-bold text-slate-700 w-12 text-center">100%</span>
                    <button onclick="setZoom(0.1)" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600"><i class="ri-add-line"></i></button>
                    <button onclick="resetZoom()" class="w-8 h-8 rounded-full hover:bg-slate-100 text-slate-600" title="适应宽度"><i class="ri-aspect-ratio-line"></i></button>
                </div>
            </div>
        </div>

        <div class="w-72 bg-white border-l flex flex-col z-20 transition-all" id="right-panel">
            <div class="px-5 py-4 border-b flex justify-between items-center">
                <h2 class="text-xs font-bold text-slate-500 uppercase tracking-widest">属性设置</h2>
                <span id="selection-tag" class="text-[10px] bg-slate-100 text-slate-500 px-2 py-0.5 rounded-full hidden">OBJECT</span>
            </div>
            
            <div id="properties-content" class="p-5 space-y-6 overflow-y-auto flex-1 opacity-50 pointer-events-none transition-opacity duration-200">
                <div id="font-section" class="hidden">
                    <label class="text-xs font-semibold text-slate-500 mb-2 block">字体 / Font</label>
                    <select id="prop-font" class="w-full border border-slate-200 rounded-lg px-2 py-1.5 text-sm bg-white focus:ring-2 focus:ring-blue-100 outline-none" onchange="updateActiveObject('font')">
                        <option value="sans-serif">系统默认 (Sans-serif)</option>
                        <option value="SimSun">宋体 (SimSun)</option>
                        <option value="Microsoft YaHei">微软雅黑 (YaHei)</option>
                        <option value="KaiTi">楷体 (KaiTi)</option>
                        <option value="SimHei">黑体 (SimHei)</option>
                        <option value="Arial">Arial</option>
                    </select>
                </div>

                <div>
                    <div class="flex justify-between mb-2">
                        <label class="text-xs font-semibold text-slate-500">颜色</label>
                        <div class="flex items-center gap-2 border rounded px-2 py-0.5 cursor-pointer hover:bg-slate-50" onclick="document.getElementById('prop-color').click()">
                            <div id="color-preview" class="w-3 h-3 rounded-full bg-black border"></div>
                            <span id="color-hex" class="text-xs font-mono text-slate-500">#000000</span>
                            <input type="color" id="prop-color" class="hidden" oninput="updateActiveObject('color')">
                        </div>
                    </div>
                    <div class="grid grid-cols-6 gap-2">
                        <div class="color-grid-btn bg-black" onclick="setColor('#000000')"></div>
                        <div class="color-grid-btn bg-gray-500" onclick="setColor('#6b7280')"></div>
                        <div class="color-grid-btn bg-red-500" onclick="setColor('#ef4444')"></div>
                        <div class="color-grid-btn bg-orange-500" onclick="setColor('#f97316')"></div>
                        <div class="color-grid-btn bg-yellow-500" onclick="setColor('#eab308')"></div>
                        <div class="color-grid-btn bg-green-500" onclick="setColor('#22c55e')"></div>
                        <div class="color-grid-btn bg-blue-500" onclick="setColor('#3b82f6')"></div>
                        <div class="color-grid-btn bg-indigo-500" onclick="setColor('#6366f1')"></div>
                        <div class="color-grid-btn bg-purple-500" onclick="setColor('#a855f7')"></div>
                        <div class="color-grid-btn bg-pink-500" onclick="setColor('#ec4899')"></div>
                        <div class="color-grid-btn bg-white" onclick="setColor('#ffffff')"></div>
                    </div>
                </div>

                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs font-semibold text-slate-500" id="size-label">大小</label>
                            <span class="text-xs font-mono text-slate-600" id="size-val">20</span>
                        </div>
                        <input type="range" id="prop-size" min="1" max="120" value="20" class="w-full accent-blue-600 h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer" oninput="updateActiveObject('size')">
                    </div>
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs font-semibold text-slate-500">透明度</label>
                            <span class="text-xs font-mono text-slate-600" id="opacity-val">100%</span>
                        </div>
                        <input type="range" id="prop-opacity" min="0" max="1" step="0.1" value="1" class="w-full accent-blue-600 h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer" oninput="updateActiveObject('opacity')">
                    </div>
                </div>

                <div id="text-styles" class="hidden">
                    <label class="text-xs font-semibold text-slate-500 mb-2 block">样式</label>
                    <div class="flex bg-slate-100 p-1 rounded-lg">
                        <button onclick="toggleBold()" class="flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm font-bold transition" id="btn-bold">B</button>
                        <button onclick="toggleItalic()" class="flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm italic transition" id="btn-italic">I</button>
                        <button onclick="toggleLinethrough()" class="flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm line-through transition" id="btn-strike">S</button>
                    </div>
                </div>

                <div class="pt-4 border-t border-slate-100">
                    <label class="text-xs font-semibold text-slate-500 mb-2 block">操作</label>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="canvas.bringForward(canvas.getActiveObject())" class="px-2 py-1.5 bg-white border rounded text-xs hover:bg-slate-50 text-slate-600">上移一层</button>
                        <button onclick="canvas.sendBackwards(canvas.getActiveObject())" class="px-2 py-1.5 bg-white border rounded text-xs hover:bg-slate-50 text-slate-600">下移一层</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="loader" class="fixed inset-0 bg-white/90 backdrop-blur-md z-50 hidden flex items-center justify-center flex-col">
        <div class="spinner border-blue-600 w-12 h-12 border-4 rounded-full border-t-transparent animate-spin"></div>
        <p class="mt-6 text-slate-600 font-medium" id="loader-text">处理中...</p>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        const { PDFDocument, degrees } = PDFLib;

        let pdfDoc = null, currentPage = 1, canvas = null, fileBytes = null;
        let pageObjects = {}; 
        let pageRotations = {}; // 存储页面旋转状态 { pageNum: angle }
        let currentZoom = 1.0, canvasBaseWidth = 0;
        const history = { undo: [], redo: [], locked: false };
        let showGrid = false;

        let drawShapeMode = null;   // 'rect' | 'circle' | 'arrow' | null
        let isDrawingShape = false;
        let startX = 0, startY = 0;
        history.locked = true;
        let tempObj = null;


        function initCanvas() {
            canvas = new fabric.Canvas('fabric-canvas', { preserveObjectStacking: true, selection: true });
            canvas.on('selection:created', onSelect);
            canvas.on('selection:updated', onSelect);
            canvas.on('selection:cleared', onClear);
            canvas.on('object:added', () => saveHistory('add'));
            canvas.on('object:modified', () => saveHistory('mod'));
            canvas.on('object:removed', () => saveHistory('rem'));

            canvas.on('mouse:down', onCanvasMouseDown);
            canvas.on('mouse:move', onCanvasMouseMove);
            canvas.on('mouse:up', onCanvasMouseUp);

        }

        // 文件加载 [修复：添加了 value 重置]
        document.getElementById('file-upload').onchange = async (e) => {
            const f = e.target.files[0]; if(!f) return;
            showLoader(true, '解析 PDF...');
            try {
                fileBytes = await f.arrayBuffer();
                document.getElementById('file-name').innerText = f.name;
                pdfDoc = await pdfjsLib.getDocument({data: fileBytes.slice(0)}).promise;
                document.getElementById('page-count').innerText = pdfDoc.numPages;
                document.getElementById('empty-state').classList.add('hidden');
                document.getElementById('canvas-wrapper').classList.remove('hidden');
                document.getElementById('bottom-bar').classList.remove('hidden');
                document.getElementById('btn-save').disabled = false;
                document.getElementById('btn-save').classList.remove('opacity-50', 'cursor-not-allowed');
                if(!canvas) initCanvas();
                pageObjects = {}; pageRotations = {}; 
                history.undo = []; history.redo = []; currentPage = 1;
                await renderPage(1); resetZoom();
            } catch(err) { alert('错误: ' + err.message); } 
            finally { 
                showLoader(false); 
                // [修复核心] 清空 input 值，确保可以重复选择同一文件或重新触发事件
                e.target.value = ''; 
            }
        };

        function stashCurrentObjects() {
            if(!canvas) return;
            const objs = canvas.getObjects();
            if(objs.length > 0) pageObjects[currentPage] = objs.map(o => o.toObject());
            else delete pageObjects[currentPage];
        }

        // 找到原本的 renderPage 函数，用这个替换
        async function renderPage(num) {
            showLoader(true, `加载第 ${num} 页...`);
            try {
                const page = await pdfDoc.getPage(num);
                const userRotation = pageRotations[num] || 0;
                const totalRotation = (page.rotate + userRotation) % 360;
                
                const viewport = page.getViewport({scale: 2.0, rotation: totalRotation});
                const tempCvs = document.createElement('canvas');
                tempCvs.width = viewport.width; tempCvs.height = viewport.height;
                
                await page.render({canvasContext: tempCvs.getContext('2d'), viewport}).promise;
                
                const bgURL = tempCvs.toDataURL('image/jpeg', 0.8);
                canvasBaseWidth = viewport.width;
                canvas.setWidth(viewport.width); canvas.setHeight(viewport.height);
                
                canvas.clear(); 
                history.undo = []; history.redo = []; updateHistoryBtns(); 

                fabric.Image.fromURL(bgURL, (img) => {
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { 
                        originX: 'left', originY: 'top', scaleX: 1, scaleY: 1, erasable: false 
                    });
                    
                    if(pageObjects[num]) {
                        history.locked = true;
                        fabric.util.enlivenObjects(pageObjects[num], (objs) => { 
                            objs.forEach(o => canvas.add(o)); 
                            canvas.renderAll(); 
                            history.locked = false; 
                            // [新增修复] 加载旧对象后，保存一次初始状态，作为撤回的基点
                            saveHistory('init');
                        });
                    } else {
                        // [新增修复] 如果是新页面，也要保存初始空白状态
                        saveHistory('init');
                    }
                    document.getElementById('page-num').innerText = num;
                    applyZoom(); showLoader(false);
                });
            } catch(e) { console.error(e); showLoader(false); }
        }

        // --- Pro Ultra Features: Rotation & Grid ---

        window.rotatePage = async (angle) => {
            stashCurrentObjects();
            const current = pageRotations[currentPage] || 0;
            // 确保角度在 0-360 之间
            let next = (current + angle) % 360;
            if (next < 0) next += 360;
            pageRotations[currentPage] = next;
            await renderPage(currentPage);
        };

        // [修复核心] 改进的清空页面逻辑
        window.clearPage = () => {
            if(confirm('确定要清空当前页面的所有标注吗？(此操作不可撤销)')) {
                // 1. 获取当前所有对象并移除（但不调用 clear()，从而保留背景图）
                const objects = canvas.getObjects();
                // 复制一份数组进行遍历删除，因为直接在 getObjects() 返回的数组上操作可能会有副作用
                [...objects].forEach(o => canvas.remove(o));

                // 2. 彻底清除内存中该页的缓存
                delete pageObjects[currentPage];

                // 3. 刷新画布
                canvas.requestRenderAll();
                
                // 4. 记录历史
                saveHistory('clear');
            }
        };

        window.toggleGrid = () => {
            showGrid = !showGrid;
            const grid = document.getElementById('grid-layer');
            if(showGrid) grid.classList.remove('hidden');
            else grid.classList.add('hidden');
        };

        // ------------------------------------------

        window.changePage = async (d) => { const next = currentPage + d; if(next < 1 || next > pdfDoc.numPages) return; stashCurrentObjects(); currentPage = next; await renderPage(currentPage); };
        window.setZoom = (d) => { currentZoom = Math.max(0.2, Math.min(3.0, currentZoom + d)); applyZoom(); };
        window.resetZoom = () => { const containerW = document.getElementById('main-scroll').clientWidth - 64; currentZoom = containerW / canvasBaseWidth; applyZoom(); };
        function applyZoom() { document.getElementById('zoom-val').innerText = Math.round(currentZoom * 100) + '%'; document.getElementById('canvas-wrapper').style.transform = `scale(${currentZoom})`; }

        // === 工具与属性 ===
        function activatePanel(type) {
            const p = document.getElementById('properties-content');
            p.classList.remove('opacity-50', 'pointer-events-none');
            const tag = document.getElementById('selection-tag');
            tag.innerText = type.toUpperCase();
            tag.classList.remove('hidden');
            
            if(type === 'text' || type === 'i-text') {
                document.getElementById('font-section').classList.remove('hidden');
                document.getElementById('text-styles').classList.remove('hidden');
                document.getElementById('size-label').innerText = '字号';
            } else {
                document.getElementById('font-section').classList.add('hidden');
                document.getElementById('text-styles').classList.add('hidden');
                document.getElementById('size-label').innerText = (type === 'path' || type === 'brush' || type === 'polyline') ? '笔触粗细' : '大小';
            }
        }

        window.setTool = (mode) => {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById(`tool-${mode}`);
            if(btn) btn.classList.add('active');

            canvas.isDrawingMode = false;
            canvas.selection = true;
            canvas.defaultCursor = 'default';
            canvas.discardActiveObject();
            canvas.requestRenderAll();

            if(mode === 'draw' || mode === 'highlight') {
                canvas.isDrawingMode = true;
                const brush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush = brush;
                activatePanel('brush'); 
                
                const color = document.getElementById('prop-color').value;
                const size = parseInt(document.getElementById('prop-size').value);
                const opacity = parseFloat(document.getElementById('prop-opacity').value);
                brush.width = size || 5;
                if(mode === 'highlight') {
                    brush.color = "rgba(255, 235, 59, 0.5)"; 
                    brush.width = 30;
                } else {
                    brush.color = hexToRgba(color, opacity);
                }
            } else if (mode === 'rect' || mode === 'circle' || mode === 'arrow') {
                // ========== 新增：鼠标拖拽画形状 ==========
                drawShapeMode = mode;
                canvas.isDrawingMode = false;
                canvas.selection = false;
                canvas.defaultCursor = 'crosshair';
                activatePanel('shape');
            } else if (mode === 'whiteout') {
                const rect = new fabric.Rect({ left: canvas.width/2 - 100, top: canvas.height/2 - 50, width: 200, height: 100, fill: 'white', stroke: '#e2e8f0', strokeWidth: 1 });
                canvas.add(rect); canvas.setActiveObject(rect); setTool('select');
            } else {
                if(!canvas.getActiveObject()) onClear();
            }
        };

        window.addText = () => {
            setTool('text');
            const color = document.getElementById('prop-color').value;
            const text = new fabric.IText('双击输入', { left: canvas.width/2 - 60, top: canvas.height/2, fill: color, fontSize: 40, fontFamily: 'sans-serif' });
            canvas.add(text); canvas.setActiveObject(text); text.enterEditing(); text.selectAll();
        };

        document.getElementById('img-upload').onchange = (e) => {
            const f = e.target.files[0]; if(!f) return;
            const r = new FileReader();
            r.onload = (res) => {
                fabric.Image.fromURL(res.target.result, (img) => {
                    img.scaleToWidth(200); img.set({left: canvas.width/2-100, top: canvas.height/2-100});
                    canvas.add(img); canvas.setActiveObject(img);
                });
            };
            r.readAsDataURL(f); e.target.value = '';
        };

        function onSelect() {
            const obj = canvas.getActiveObject(); 
            if(!obj) return;
            
            activatePanel(obj.type);

            // 1. --- 修复颜色读取逻辑 ---
            // 优先读取描边色(stroke)，如果没有描边(比如文字)则读取填充色(fill)
            // 这样箭头(polyline)和文字(text)都能正确显示颜色
            let activeColor = obj.fill;
            if ((obj.type === 'path' || obj.type === 'polyline' || obj.type === 'rect' || obj.type === 'circle') && obj.stroke) {
                activeColor = obj.stroke;
            }

            // 更新颜色选择器显示
            if(activeColor && typeof activeColor === 'string' && activeColor.startsWith('#')) {
                document.getElementById('prop-color').value = activeColor;
                document.getElementById('color-hex').innerText = activeColor;
                document.getElementById('color-preview').style.backgroundColor = activeColor;
            }

            // 2. --- 根据类型更新属性面板 ---
            if(obj.type === 'i-text') {
                // 如果是文字
                document.getElementById('prop-font').value = obj.fontFamily || 'sans-serif';
                document.getElementById('prop-size').value = obj.fontSize;
                document.getElementById('size-val').innerText = obj.fontSize;
                
                // 更新文字样式按钮状态
                document.getElementById('btn-bold').className = obj.fontWeight==='bold' ? 'flex-1 py-1.5 rounded bg-blue-100 text-blue-600 text-sm font-bold transition' : 'flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm font-bold transition';
                document.getElementById('btn-italic').className = obj.fontStyle==='italic' ? 'flex-1 py-1.5 rounded bg-blue-100 text-blue-600 text-sm italic transition' : 'flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm italic transition';
                document.getElementById('btn-strike').className = obj.linethrough ? 'flex-1 py-1.5 rounded bg-blue-100 text-blue-600 text-sm line-through transition' : 'flex-1 py-1.5 rounded hover:bg-white hover:shadow-sm text-sm line-through transition';
            
            } else if (obj.type === 'path' || obj.type === 'polyline' || obj.type === 'rect' || obj.type === 'circle') {
                // 如果是 线条、箭头、矩形、圆形
                // 统一读取 strokeWidth (边框粗细)
                if (obj.strokeWidth) {
                    document.getElementById('prop-size').value = obj.strokeWidth;
                    document.getElementById('size-val').innerText = obj.strokeWidth.toFixed(0);
                }
            }

            // 3. --- 更新透明度 (通用属性，放在最后) ---
            document.getElementById('prop-opacity').value = obj.opacity;
            document.getElementById('opacity-val').innerText = Math.round(obj.opacity * 100) + '%';
        }

        function onClear() {
            if(canvas.isDrawingMode) return;
            document.getElementById('properties-content').classList.add('opacity-50', 'pointer-events-none');
            document.getElementById('selection-tag').classList.add('hidden');
        }

        window.updateActiveObject = (key, val) => {
            const obj = canvas.getActiveObject();
            if(val === undefined) {
                if(key === 'color') val = document.getElementById('prop-color').value;
                if(key === 'size') val = parseInt(document.getElementById('prop-size').value);
                if(key === 'opacity') val = parseFloat(document.getElementById('prop-opacity').value);
                if(key === 'font') val = document.getElementById('prop-font').value;
            }
            if(key === 'color') { document.getElementById('color-hex').innerText = val; document.getElementById('color-preview').style.backgroundColor = val; }
            if(key === 'size') document.getElementById('size-val').innerText = val;
            if(key === 'opacity') document.getElementById('opacity-val').innerText = Math.round(val*100)+'%';

            if(obj) {
                if(key === 'color') { 
                    // 实体形状改填充
                    if(obj.type === 'i-text' || obj.type === 'rect' || obj.type === 'circle') obj.set('fill', val); 
                    // [修改处]：线条形状改描边 (增加 polyline)
                    if(obj.type === 'path' || obj.type === 'polyline' || obj.type === 'rect' || obj.type === 'circle') obj.set('stroke', val); 
                }

                if(key === 'size') { 
                    if(obj.type === 'i-text') obj.set('fontSize', val); 
                    // [修改处]：线条粗细 (增加 polyline)
                    else if(obj.type === 'path' || obj.type === 'polyline' || obj.type === 'rect' || obj.type === 'circle') obj.set('strokeWidth', val); 
                }
                if(key === 'opacity') obj.set('opacity', val);
                if(key === 'font' && obj.type === 'i-text') obj.set('fontFamily', val);
                canvas.requestRenderAll(); saveHistory('mod');
            }
            if (canvas.isDrawingMode && canvas.freeDrawingBrush) {
                if (key === 'color' || key === 'opacity') {
                    const c = document.getElementById('prop-color').value;
                    const o = parseFloat(document.getElementById('prop-opacity').value);
                    canvas.freeDrawingBrush.color = hexToRgba(c, o);
                }
                if (key === 'size') canvas.freeDrawingBrush.width = parseInt(document.getElementById('prop-size').value);
            }
        };

        window.setColor = (hex) => {
            document.getElementById('prop-color').value = hex === 'transparent' ? '#ffffff' : hex;
            updateActiveObject('color', hex);
        };

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        window.toggleBold = () => { const o=canvas.getActiveObject(); if(o&&o.type==='i-text'){ o.set('fontWeight', o.fontWeight==='bold'?'normal':'bold'); canvas.requestRenderAll(); saveHistory('mod'); onSelect(); }};
        window.toggleItalic = () => { const o=canvas.getActiveObject(); if(o&&o.type==='i-text'){ o.set('fontStyle', o.fontStyle==='italic'?'normal':'italic'); canvas.requestRenderAll(); saveHistory('mod'); onSelect(); }};
        window.toggleLinethrough = () => { const o=canvas.getActiveObject(); if(o&&o.type==='i-text'){ o.set('linethrough', !o.linethrough); canvas.requestRenderAll(); saveHistory('mod'); onSelect(); }};

        function saveHistory(type) {
            if(history.locked) return;

            const snap = JSON.stringify(canvas.toJSON());
            if (history.undo.length && history.undo[history.undo.length - 1] === snap) return; // ✅ 去重

            if(history.undo.length > 50) history.undo.shift();
            history.undo.push(snap);
            history.redo = [];
            updateHistoryBtns();
        }

        
        // 替换原本的 undo 和 redo
        window.undo = () => {
            // 必须至少保留一个初始状态，所以长度 <= 1 时不能撤回
            if(history.undo.length <= 1) return;

            // 1. 弹出栈顶（这是当前屏幕看到的状态），把它移到 Redo 栈去
            const current = history.undo.pop();
            history.redo.push(current);

            // 2. 现在栈顶变成了“上一步的状态”，我们读取它（Peek），但不要弹出它
            // 因为这变成了新的“当前状态”
            const prev = history.undo[history.undo.length - 1];

            history.locked = true;
            canvas.loadFromJSON(JSON.parse(prev), () => {
                canvas.renderAll();
                history.locked = false;
                updateHistoryBtns(); // 别忘了更新按钮状态
            });
        };

        window.redo = () => {
            if(history.redo.length === 0) return;

            // 1. 从 Redo 栈取出下一步的状态
            const next = history.redo.pop();
            
            // 2. 把它推入 Undo 栈，因为它即将成为当前状态
            history.undo.push(next);

            history.locked = true;
            canvas.loadFromJSON(JSON.parse(next), () => {
                canvas.renderAll();
                history.locked = false;
                updateHistoryBtns();
            });
        };

        // 同时也更新一下按钮状态判断逻辑，因为现在我们保留了初始状态
        function updateHistoryBtns() {
            // 只有当 Undo 栈里有多于 1 个状态（初始状态 + 至少 1 个操作）时，才能撤回
            document.getElementById('btn-undo').disabled = history.undo.length <= 1;
            document.getElementById('btn-redo').disabled = history.redo.length === 0;
            
            // 更新样式
            document.getElementById('btn-undo').className = history.undo.length <= 1 ? 
                'w-8 h-8 flex items-center justify-center rounded text-slate-300 cursor-not-allowed' : 
                'w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm text-slate-600';
            
            document.getElementById('btn-redo').className = history.redo.length === 0 ? 
                'w-8 h-8 flex items-center justify-center rounded text-slate-300 cursor-not-allowed' : 
                'w-8 h-8 flex items-center justify-center rounded hover:bg-white hover:shadow-sm text-slate-600';
        }

        window.deleteActiveObject = () => { const actives = canvas.getActiveObjects(); if(actives.length) { canvas.discardActiveObject(); actives.forEach(o => canvas.remove(o)); saveHistory('del'); }};
        let _clipboard;
        window.copyObject = () => { const o = canvas.getActiveObject(); if(o) o.clone(c => _clipboard = c); };
        window.pasteObject = () => { if(!_clipboard) return; _clipboard.clone(c => { canvas.discardActiveObject(); c.set({left: c.left+20, top: c.top+20, evented: true}); if(c.type === 'activeSelection') { c.canvas = canvas; c.forEachObject(o => canvas.add(o)); c.setCoords(); } else canvas.add(c); canvas.setActiveObject(c); canvas.requestRenderAll(); saveHistory('paste'); }); };
        window.addEventListener('keydown', (e) => {
            if((e.key === 'Delete' || e.key === 'Backspace') && (!canvas.getActiveObject() || !canvas.getActiveObject().isEditing)) deleteActiveObject();
            if((e.ctrlKey||e.metaKey) && e.key === 'c') copyObject();
            if((e.ctrlKey||e.metaKey) && e.key === 'v') pasteObject();
            if((e.ctrlKey||e.metaKey) && e.key === 'z') undo();
            if((e.ctrlKey||e.metaKey) && e.key === 'y') redo();
        });

        // 1. 添加箭头 (修复版)
        window.addArrow = () => {
            setTool('select');
            const color = document.getElementById('prop-color').value;
            const size = parseInt(document.getElementById('prop-size').value) || 4;

            // 使用 Polyline（折线）代替 Path，兼容性更好，不会隐形
            // 坐标点：起点 -> 终点 -> 上翼 -> 终点 -> 下翼
            const arrow = new fabric.Polyline([
                { x: 0, y: 0 },
                { x: 100, y: 0 },
                { x: 85, y: -10 },
                { x: 100, y: 0 },
                { x: 85, y: 10 }
            ], {
                left: canvas.width / 2 - 50,
                top: canvas.height / 2,
                fill: 'transparent', // 重点：必须显式设置为 transparent
                stroke: color,
                strokeWidth: size,
                strokeLineCap: 'round', // 让拐角圆润
                strokeLineJoin: 'round',
                originX: 'center',
                originY: 'center',
                objectCaching: false // 关闭缓存，防止模糊或不显示
            });

            canvas.add(arrow);
            canvas.setActiveObject(arrow);
            canvas.requestRenderAll(); // 强制刷新画布
            saveHistory('add_arrow');
        };

        // === 新增：图形工具箱 ===

        function getPointer(e) {
            return canvas.getPointer(e.e);
        }

        function onCanvasMouseDown(opt) {
            if (!drawShapeMode) return;

            history.locked = true;   // ✅ 新增：绘制中锁历史

            const p = getPointer(opt);
            isDrawingShape = true;
            startX = p.x; startY = p.y;

            const color = document.getElementById('prop-color').value;
            const sw = parseInt(document.getElementById('prop-size').value) || 3;
            const opacity = parseFloat(document.getElementById('prop-opacity').value) || 1;

            // 先把选择关掉，防止拖拽时选中别的对象
            canvas.selection = false;
            canvas.discardActiveObject();

            if (drawShapeMode === 'rect') {
                tempObj = new fabric.Rect({
                    left: startX, top: startY,
                    width: 1, height: 1,
                    fill: 'transparent',
                    stroke: color,
                    strokeWidth: sw,
                    opacity,
                    rx: 5, ry: 5,
                    selectable: false,
                    evented: false
                });
                canvas.add(tempObj);

            } else if (drawShapeMode === 'circle') {
                tempObj = new fabric.Ellipse({
                    left: startX, top: startY,
                    rx: 1, ry: 1,
                    fill: 'transparent',
                    stroke: color,
                    strokeWidth: sw,
                    opacity,
                    originX: 'left',
                    originY: 'top',
                    selectable: false,
                    evented: false
                });
                canvas.add(tempObj);

            } else if (drawShapeMode === 'arrow') {
                // 用 line + triangle 组合；先创建，后续 move 时更新位置/角度
                const line = new fabric.Line([startX, startY, startX + 1, startY + 1], {
                    stroke: color,
                    strokeWidth: sw,
                    selectable: false,
                    evented: false
                });

                const head = new fabric.Triangle({
                    width: 14, height: 14,
                    fill: color,
                    left: startX + 1, top: startY + 1,
                    originX: 'center', originY: 'center',
                    angle: 0,
                    selectable: false,
                    evented: false
                });

                tempObj = new fabric.Group([line, head], {
                    selectable: false,
                    evented: false
                });
                canvas.add(tempObj);
            }

            canvas.requestRenderAll();
        }

        function onCanvasMouseMove(opt) {
            if (!isDrawingShape || !tempObj) return;

            const p = getPointer(opt);
            const x = p.x, y = p.y;

            const left = Math.min(startX, x);
            const top = Math.min(startY, y);
            const w = Math.abs(x - startX);
            const h = Math.abs(y - startY);

            if (drawShapeMode === 'rect') {
                tempObj.set({ left, top, width: w, height: h });

            } else if (drawShapeMode === 'circle') {
                // 椭圆：left/top 是包围盒左上角，rx/ry 是半径
                tempObj.set({
                    left,
                    top,
                    rx: w / 2,
                    ry: h / 2
                });

            } else if (drawShapeMode === 'arrow') {
                const [line, head] = tempObj._objects;

                // 更新线
                line.set({ x1: startX, y1: startY, x2: x, y2: y });

                // 箭头角度
                const angle = Math.atan2(y - startY, x - startX) * 180 / Math.PI;

                // 更新箭头头部位置与角度
                head.set({ left: x, top: y, angle: angle + 90 });

                tempObj.addWithUpdate();
            }

            canvas.requestRenderAll();
        }

        function onCanvasMouseUp() {
            if (!isDrawingShape || !tempObj) return;

            // 固化：让它变成可选、可编辑对象
            tempObj.set({ selectable: true, evented: true });
            canvas.setActiveObject(tempObj);

            // 结束本次绘制
            isDrawingShape = false;
            tempObj = null;

            canvas.selection = true;
            canvas.requestRenderAll();

            // ✅ 关键：现在才解锁，并保存一次最终结果
            history.locked = false;
            saveHistory('draw_shape');

            // 画完回到选择
            setTool('select');
            drawShapeMode = null;
        }

        // 导出
        window.savePDF = async () => {
            stashCurrentObjects(); // 保存当前状态
            showLoader(true, '正在进行坐标系校正与合成...');
            
            try {
                // 1. 加载源文件
                const srcDoc = await PDFDocument.load(fileBytes);
                const pages = srcDoc.getPages();
                const totalPages = srcDoc.getPageCount();
                const { degrees } = PDFLib; 

                for (let i = 0; i < totalPages; i++) {
                    const pageNum = i + 1;
                    const pdfPage = pages[i];
                    
                    // --- A. 获取原始信息 ---
                    const { width: originalWidth, height: originalHeight } = pdfPage.getSize();
                    const currentRotation = pdfPage.getRotation().angle;
                    const userRotation = pageRotations[pageNum] || 0;
                    
                    let finalRotation = (currentRotation + userRotation) % 360;
                    if (finalRotation < 0) finalRotation += 360;
                    
                    // --- B. 设置元数据旋转 ---
                    pdfPage.setRotation(degrees(finalRotation));

                    // --- C. 准备标注层图片 ---
                    if (pageObjects[pageNum] && pageObjects[pageNum].length > 0) {
                        
                        const isSideways = finalRotation === 90 || finalRotation === 270;
                        const visualWidth = isSideways ? originalHeight : originalWidth;
                        const visualHeight = isSideways ? originalWidth : originalHeight;

                        const staticCvs = new fabric.StaticCanvas(null, { 
                            width: visualWidth * 2, 
                            height: visualHeight * 2
                        });

                        await new Promise(r => {
                            fabric.util.enlivenObjects(pageObjects[pageNum], (objs) => {
                                objs.forEach(o => staticCvs.add(o));
                                r();
                            });
                        });
                        
                        staticCvs.renderAll();
                        const imgData = staticCvs.toDataURL({ format: 'png', multiplier: 1 });
                        const pngImage = await srcDoc.embedPng(imgData);

                        let drawOptions = {};

                        switch (finalRotation) {
                            case 0:
                                drawOptions = { x: 0, y: 0, width: visualWidth, height: visualHeight };
                                break;
                            case 90:
                                drawOptions = {
                                    x: originalWidth, y: 0,
                                    width: visualWidth, height: visualHeight,
                                    rotate: degrees(90)
                                };
                                break;
                            case 180:
                                drawOptions = {
                                    x: originalWidth, y: originalHeight,
                                    width: visualWidth, height: visualHeight,
                                    rotate: degrees(180)
                                };
                                break;
                            case 270:
                                drawOptions = {
                                    x: 0, y: originalHeight,
                                    width: visualWidth, height: visualHeight,
                                    rotate: degrees(270)
                                };
                                break;
                        }

                        pdfPage.drawImage(pngImage, drawOptions);
                    }
                }

                const bytes = await srcDoc.save();
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `edited_fixed_${Date.now()}.pdf`;
                link.click();

            } catch(e) { 
                console.error(e); 
                alert('导出失败: ' + e.message); 
            } finally { 
                showLoader(false); 
            }
        };
        
        function showLoader(show, text) { const l = document.getElementById('loader'); if(show) { l.classList.remove('hidden'); if(text)document.getElementById('loader-text').innerText=text; } else l.classList.add('hidden'); }
    </script>
</body>
</html>
