<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>本地 PDF 压缩工具 (纯前端安全版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <style>
        .drag-active { border-color: #3b82f6; background-color: #eff6ff; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #3b82f6; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans text-gray-700">

    <div class="max-w-2xl mx-auto py-10 px-4">
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-900 mb-2">PDF 极致压缩工具</h1>
            <p class="text-sm text-gray-500">所有处理均在本地浏览器完成，文件不会上传至服务器，安全无忧。</p>
        </div>

        <div class="bg-white rounded-xl shadow-lg p-6 border border-gray-100">
            
            <div id="drop-zone" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center transition-all cursor-pointer hover:border-blue-400 hover:bg-gray-50">
                <input type="file" id="file-input" accept="application/pdf" class="hidden">
                <div class="space-y-2">
                    <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                    <p class="text-lg font-medium text-gray-700">点击或拖拽 PDF 文件到此处</p>
                    <p class="text-xs text-gray-400" id="file-name">支持任意大小的 PDF 文件</p>
                </div>
            </div>

            <div id="settings-area" class="mt-6 hidden space-y-6">
                <div class="bg-blue-50 p-4 rounded-md text-sm text-blue-800 border border-blue-100">
                    <span class="font-bold">注意：</span>此模式会将 PDF 页面转为图片进行压缩。处理后的 PDF 文本将<b>不可选中</b>。
                </div>

                <div>
                    <div class="flex justify-between mb-2">
                        <label class="font-medium text-gray-700">图片质量 (压缩率)</label>
                        <span id="quality-val" class="text-blue-600 font-bold">0.6</span>
                    </div>
                    <input type="range" id="quality" min="0.1" max="1.0" step="0.1" value="0.6" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    <p class="text-xs text-gray-500 mt-1">值越小体积越小，但画面噪点越多。</p>
                </div>

                <div>
                    <div class="flex justify-between mb-2">
                        <label class="font-medium text-gray-700">清晰度 (分辨率缩放)</label>
                        <span id="scale-val" class="text-blue-600 font-bold">1.0x</span>
                    </div>
                    <input type="range" id="scale" min="0.5" max="2.0" step="0.1" value="1.0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    <p class="text-xs text-gray-500 mt-1">降低分辨率可显著减小体积，但文字会变模糊。</p>
                </div>

                <button id="compress-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors flex justify-center items-center gap-2">
                    开始压缩
                </button>
            </div>

            <div id="progress-area" class="mt-8 hidden text-center">
                <div class="spinner mx-auto mb-4"></div>
                <p class="text-gray-700 font-medium mb-1">正在处理中...</p>
                <p class="text-sm text-gray-500" id="progress-text">正在初始化渲染引擎...</p>
                <div class="w-full bg-gray-200 rounded-full h-2.5 mt-3">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>

            <div id="result-area" class="mt-8 hidden text-center space-y-4">
                <div class="text-green-500 text-5xl mb-2">✓</div>
                <h3 class="text-xl font-bold text-gray-800">压缩完成!</h3>
                
                <div class="flex justify-center gap-8 text-sm text-gray-600 bg-gray-50 p-3 rounded-lg">
                    <div>
                        <p>原始大小</p>
                        <p class="font-bold text-gray-900" id="old-size">-</p>
                    </div>
                    <div class="border-r border-gray-300"></div>
                    <div>
                        <p>压缩后</p>
                        <p class="font-bold text-green-600" id="new-size">-</p>
                    </div>
                    <div class="border-r border-gray-300"></div>
                    <div>
                        <p>减少比例</p>
                        <p class="font-bold text-blue-600" id="reduce-ratio">-</p>
                    </div>
                </div>

                <a id="download-link" href="#" class="inline-block w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                    下载压缩后的 PDF
                </a>
                <button onclick="location.reload()" class="text-sm text-gray-500 hover:text-gray-700 underline">压缩另一个文件</button>
            </div>
        </div>
    </div>

    <script>
        // 配置 Worker 路径 (PDF.js 需要)
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const fileNameDisplay = document.getElementById('file-name');
        const settingsArea = document.getElementById('settings-area');
        const compressBtn = document.getElementById('compress-btn');
        const progressArea = document.getElementById('progress-area');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const resultArea = document.getElementById('result-area');
        
        let currentFile = null;

        // 滑块数值显示更新
        document.getElementById('quality').addEventListener('input', (e) => document.getElementById('quality-val').innerText = e.target.value);
        document.getElementById('scale').addEventListener('input', (e) => document.getElementById('scale-val').innerText = e.target.value + 'x');

        // 文件拖拽与选择处理
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-active'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-active'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-active');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) handleFile(e.target.files[0]);
        });

        function handleFile(file) {
            if (file.type !== 'application/pdf') {
                alert('请上传 PDF 文件');
                return;
            }
            currentFile = file;
            fileNameDisplay.innerText = `当前文件: ${file.name} (${formatBytes(file.size)})`;
            fileNameDisplay.classList.add('text-blue-600', 'font-bold');
            settingsArea.classList.remove('hidden');
            resultArea.classList.add('hidden'); // 重置结果区
        }

        // 核心压缩逻辑
        compressBtn.addEventListener('click', async () => {
            if (!currentFile) return;

            // UI 状态更新
            settingsArea.classList.add('hidden');
            dropZone.classList.add('hidden');
            progressArea.classList.remove('hidden');

            try {
                const arrayBuffer = await currentFile.arrayBuffer();
                const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const totalPages = pdfDoc.numPages;

                // 创建新的 PDF 文档
                const newPdfDoc = await PDFLib.PDFDocument.create();

                const quality = parseFloat(document.getElementById('quality').value);
                const scale = parseFloat(document.getElementById('scale').value);

                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    // 更新进度条
                    const percent = Math.round((pageNum / totalPages) * 100);
                    progressBar.style.width = `${percent}%`;
                    progressText.innerText = `正在处理第 ${pageNum} / ${totalPages} 页...`;

                    // 1. 获取原始页面
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: scale });

                    // 2. 渲染到 Canvas
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    // 3. 压缩：Canvas 转 JPEG DataURL
                    const imgDataUrl = canvas.toDataURL('image/jpeg', quality);

                    // 4. 将压缩后的 JPEG 嵌入新 PDF
                    const jpgImage = await newPdfDoc.embedJpg(imgDataUrl);
                    
                    // 保持原始页面的宽高比例，但使用新的压缩图像
                    // 注意：这里使用 viewport 的尺寸来定义页面大小
                    const newPage = newPdfDoc.addPage([viewport.width, viewport.height]);
                    newPage.drawImage(jpgImage, {
                        x: 0,
                        y: 0,
                        width: viewport.width,
                        height: viewport.height,
                    });
                    
                    // 简单的延迟以允许 UI 刷新（防止浏览器卡死）
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // 保存并生成下载
                progressText.innerText = '正在生成最终文件...';
                const pdfBytes = await newPdfDoc.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                
                showResult(blob);

            } catch (error) {
                console.error(error);
                alert('处理出错，请检查文件是否加密或损坏。');
                location.reload();
            }
        });

        function showResult(blob) {
            progressArea.classList.add('hidden');
            resultArea.classList.remove('hidden');

            // 计算数据
            const oldSize = currentFile.size;
            const newSize = blob.size;
            const ratio = ((oldSize - newSize) / oldSize * 100).toFixed(1);

            document.getElementById('old-size').innerText = formatBytes(oldSize);
            document.getElementById('new-size').innerText = formatBytes(newSize);
            
            const ratioEl = document.getElementById('reduce-ratio');
            if (newSize < oldSize) {
                ratioEl.innerText = `↓ ${ratio}%`;
                ratioEl.className = 'font-bold text-green-600';
            } else {
                ratioEl.innerText = `↑ ${(newSize/oldSize).toFixed(2)}x`;
                ratioEl.className = 'font-bold text-red-500';
                alert('提示：文件变大了！\n这通常是因为原文件已经是纯文本，而转换成图片增加了体积。\n建议降低"清晰度"或"质量"再试一次。');
            }

            const url = URL.createObjectURL(blob);
            const link = document.getElementById('download-link');
            link.href = url;
            link.download = `compressed_${currentFile.name}`;
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
