<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Data Processor</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SheetJS library for reading and writing Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Chart.js library for drawing charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chart.js plugin to display labels on charts -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <style>
        /* Custom styles for tabs and tables */
        body {
            font-family: 'Inter', sans-serif;
        }
        .tab-button.active {
            border-color: #3b82f6;
            color: #3b82f6;
            background-color: #eff6ff;
        }
        /* Styles for the dual-range slider */
        .range-slider-container {
            position: relative;
            width: 100%;
            height: 20px;
        }
        .range-slider-container input[type="range"] {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            pointer-events: none;
            transform: translateY(-50%);
        }
        .range-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        .range-slider-container input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }
        .slider-track, .slider-range {
            position: absolute;
            width: 100%;
            height: 6px;
            top: 50%;
            transform: translateY(-50%);
            border-radius: 3px;
        }
        .slider-track {
            background-color: #d1d5db; /* gray-300 */
        }
        .slider-range {
            background-color: #3b82f6; /* blue-500 */
        }
        .range-slider-container input[type="range"].thumb-z-1 { z-index: 1; }
        .range-slider-container input[type="range"].thumb-z-2 { z-index: 2; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <div class="max-w-5xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8">
            <!-- Header section -->
            <div class="text-center mb-8">
                <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Excel Data Processor</h1>
                <p class="text-gray-600 mt-2">Upload your XLSX file, and the system will automatically process data, generate charts, and reports</p>
            </div>

            <!-- File upload area -->
            <div class="mb-8 p-6 border-2 border-dashed border-gray-300 rounded-lg text-center bg-gray-50 hover:bg-gray-100 transition-colors">
                <label for="fileInput" class="cursor-pointer">
                    <div class="text-blue-600 font-semibold text-lg">
                        Click here to select a file
                    </div>
                    <div class="text-sm text-gray-500 mt-1">
                        Please ensure the data is on the first sheet of the .xlsx file.
                    </div>
                </label>
                <input type="file" id="fileInput" class="hidden" accept=".xlsx">
            </div>

            <!-- Message area -->
            <div id="message" class="mb-6"></div>
            
            <!-- Main tab buttons container -->
            <div id="tab-buttons" class="flex flex-wrap border-b border-gray-200 mb-4"></div>

            <!-- Output container -->
            <div id="output" class="space-y-8"></div>
        </div>
    </div>

    <script>
        window.chartInstances = [];

        const fileInput = document.getElementById('fileInput');
        const outputDiv = document.getElementById('output');
        const messageDiv = document.getElementById('message');
        const tabButtonsDiv = document.getElementById('tab-buttons');

        fileInput.addEventListener('change', handleFile);

        function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            clearContent();
            displayMessage('Processing file...', 'blue');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    if (workbook.SheetNames.length === 0) {
                        throw new Error(`Error: No sheets found in the workbook.`);
                    }
                    const sheetName = workbook.SheetNames[0]; 
                    const worksheet = workbook.Sheets[sheetName];

                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false });
                    if (jsonData.length === 0) throw new Error(`Error: No data found in the first sheet ('${sheetName}').`);
                    
                    const requiredHeaders = ['Rating Group ID', 'Create Time', 'Number of successfully sent messages'];
                    const actualHeaders = Object.keys(jsonData[0]);
                    const missingHeaders = requiredHeaders.filter(header => !actualHeaders.includes(header));
                    if (missingHeaders.length > 0) throw new Error(`Error: Missing required headers: ${missingHeaders.join(', ')}`);

                    const processedData = processData(jsonData);
                    renderData(processedData);
                    displayMessage('File processed successfully!', 'green');
                } catch (error) {
                    console.error(error);
                    displayMessage(error.message, 'red');
                }
            };
            reader.onerror = () => displayMessage('Error reading the file.', 'red');
            reader.readAsArrayBuffer(file);
        }

        function processData(data) {
            const groups = {}; // Structure: { 'groupId': { 'YYYY-MM-DD': { tableData: {}, chartData: [] } } }
            
            data.forEach(row => {
                const groupId = row['Rating Group ID'];
                
                if (!groupId) {
                    return; // Acts as 'continue' in a forEach loop
                }

                const createTimeStr = row['Create Time'];
                const messages = Number(row['Number of successfully sent messages']) || 0;
                
                if (!createTimeStr) return;

                const createTime = new Date(createTimeStr);
                if (isNaN(createTime.getTime())) return;

                const dateStr = createTime.getFullYear() + '-' + 
                                String(createTime.getMonth() + 1).padStart(2, '0') + '-' + 
                                String(createTime.getDate()).padStart(2, '0');

                if (!groups[groupId]) groups[groupId] = {};
                if (!groups[groupId][dateStr]) {
                    groups[groupId][dateStr] = { tableData: {}, chartData: [] };
                }
                
                if (!groups[groupId][dateStr].tableData[createTimeStr]) {
                    groups[groupId][dateStr].tableData[createTimeStr] = 0;
                }
                groups[groupId][dateStr].tableData[createTimeStr] += messages;
                groups[groupId][dateStr].chartData.push({ time: createTime, value: messages });
            });
            
            return groups;
        }

        function renderData(data) {
            const groupIds = Object.keys(data).sort();
            if (groupIds.length === 0) {
                displayMessage('No valid data found for grouping. Please check if "Rating Group ID" column has values.', 'yellow');
                return;
            }

            groupIds.forEach((groupId, index) => {
                const button = document.createElement('button');
                button.textContent = `Group: ${groupId}`;
                button.className = 'tab-button -mb-px mr-1 py-2 px-4 border-b-2 border-transparent text-gray-600 hover:text-blue-600 focus:outline-none transition-colors';
                button.dataset.target = `content-group-${groupId.replace(/\s+/g, '-')}`;
                tabButtonsDiv.appendChild(button);

                const groupContentDiv = document.createElement('div');
                groupContentDiv.id = `content-group-${groupId.replace(/\s+/g, '-')}`;
                groupContentDiv.className = 'tab-content';
                
                const groupDataByDate = data[groupId];
                
                // Combine all data for the current group
                const allChartData = Object.values(groupDataByDate).flatMap(d => d.chartData);
                const allTableData = Object.values(groupDataByDate).reduce((acc, d) => ({ ...acc, ...d.tableData }), {});

                // Create a single content area for the group's chart and table
                const contentArea = document.createElement('div');
                contentArea.appendChild(createChartSection(groupId, allChartData));
                contentArea.appendChild(createTableForGroup(allTableData));
                groupContentDiv.appendChild(contentArea);
                
                outputDiv.appendChild(groupContentDiv);

                if (index > 0) {
                    groupContentDiv.classList.add('hidden');
                } else {
                    button.classList.add('active');
                }
            });

            addTabEventListeners();
        }

        function createChartSection(groupId, chartData) {
            const section = document.createElement('div');
            section.className = 'chart-container mb-8 p-4 border rounded-lg shadow-sm bg-white';

            const headerDiv = document.createElement('div');
            headerDiv.className = 'flex justify-between items-center mb-2';
            const title = document.createElement('h3');
            title.className = 'text-lg font-semibold text-gray-800';
            title.textContent = 'Message Volume Bar Chart';
            headerDiv.appendChild(title);
            const downloadButton = document.createElement('button');
            downloadButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg> Download Chart Data`;
            downloadButton.className = 'bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors shadow-sm flex items-center text-sm';
            headerDiv.appendChild(downloadButton);
            section.appendChild(headerDiv);

            // Top controls container
            const topControlsContainer = document.createElement('div');
            topControlsContainer.className = 'p-4 bg-gray-50 rounded-lg border mb-4';

            // Granularity Controls
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'granularity-controls mb-4 flex items-center gap-x-4 gap-y-2 flex-wrap';
            const label = document.createElement('span');
            label.className = 'text-sm font-medium text-gray-600';
            label.textContent = 'Time Granularity:';
            controlsDiv.appendChild(label);
            const intervals = [{ label: '5 Minutes', value: 5 }, { label: '15 Minutes', value: 15 }, { label: '30 Minutes', value: 30 }, { label: '1 Hour', value: 60 }];
            intervals.forEach((interval, index) => {
                const radioLabel = document.createElement('label');
                radioLabel.className = 'inline-flex items-center text-sm cursor-pointer';
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = `granularity-${groupId}`;
                radio.value = interval.value;
                radio.className = 'form-radio h-4 w-4 text-blue-600 focus:ring-blue-500';
                if (index === 3) radio.checked = true;
                radioLabel.appendChild(radio);
                radioLabel.append(` ${interval.label}`);
                controlsDiv.appendChild(radioLabel);
            });
            topControlsContainer.appendChild(controlsDiv);

            // Time Range Controls
            const timeSelectorsDiv = document.createElement('div');
            timeSelectorsDiv.className = 'flex flex-col sm:flex-row justify-between items-center gap-4';

            // Start Time Dropdown
            const startDiv = document.createElement('div');
            startDiv.className = 'flex items-center gap-2';
            startDiv.innerHTML = `<label for="start-time-${groupId}" class="text-sm font-medium text-gray-700">Start Time:</label>`;
            const startTimeSelect = document.createElement('select');
            startTimeSelect.id = `start-time-${groupId}`;
            startTimeSelect.className = 'p-1 border border-gray-300 rounded-md shadow-sm text-sm w-48';
            startDiv.appendChild(startTimeSelect);
            
            // End Time Dropdown
            const endDiv = document.createElement('div');
            endDiv.className = 'flex items-center gap-2';
            endDiv.innerHTML = `<label for="end-time-${groupId}" class="text-sm font-medium text-gray-700">End Time:</label>`;
            const endTimeSelect = document.createElement('select');
            endTimeSelect.id = `end-time-${groupId}`;
            endTimeSelect.className = 'p-1 border border-gray-300 rounded-md shadow-sm text-sm w-48';
            endDiv.appendChild(endTimeSelect);

            timeSelectorsDiv.appendChild(startDiv);
            timeSelectorsDiv.appendChild(endDiv);
            topControlsContainer.appendChild(timeSelectorsDiv);
            
            section.appendChild(topControlsContainer);

            // Chart
            const chartWrapper = document.createElement('div');
            chartWrapper.className = 'relative h-96 w-full';
            const canvas = document.createElement('canvas');
            chartWrapper.appendChild(canvas);
            section.appendChild(chartWrapper);

            // Slider Controls (now below the chart)
            const sliderControlsContainer = document.createElement('div');
            sliderControlsContainer.className = 'mt-4 pt-4';

            // Slider
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'range-slider-container';
            const sliderTrack = document.createElement('div');
            sliderTrack.className = 'slider-track';
            const sliderRange = document.createElement('div');
            sliderRange.className = 'slider-range';
            const startSlider = document.createElement('input');
            startSlider.type = 'range';
            startSlider.className = 'thumb-z-1';
            const endSlider = document.createElement('input');
            endSlider.type = 'range';
            endSlider.className = 'thumb-z-2';
            
            sliderContainer.append(sliderTrack, sliderRange, startSlider, endSlider);
            sliderControlsContainer.appendChild(sliderContainer);
            section.appendChild(sliderControlsContainer);
            
            // Chart Initialization and Update Logic
            setTimeout(() => {
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                const gradient = ctx.createLinearGradient(0, 0, 0, 384);
                gradient.addColorStop(0, 'rgba(59, 130, 246, 0.7)');
                gradient.addColorStop(1, 'rgba(147, 197, 253, 0.3)');

                const chart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: [], datasets: [{ label: 'Number of successfully sent messages', data: [], backgroundColor: gradient, borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 1.5, borderRadius: 6, hoverBackgroundColor: 'rgba(37, 99, 235, 1)' }] },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: { y: { beginAtZero: true, title: { display: true, text: 'Total Messages', font: { size: 14 } }, grid: { color: '#e5e7eb' } }, x: { title: { display: true, text: 'Time Period', font: { size: 14 } }, grid: { display: false } } },
                        plugins: { legend: { display: false }, tooltip: { enabled: true, backgroundColor: '#1f2937', titleFont: { size: 14 }, bodyFont: { size: 12 }, padding: 12, cornerRadius: 6, displayColors: false, callbacks: { label: context => `${context.dataset.label || ''}: ${context.parsed.y || 0}` } }, datalabels: { anchor: 'end', align: 'top', color: '#374151', font: { weight: 'bold', size: 11, }, formatter: (value) => value > 0 ? new Intl.NumberFormat('en-US').format(value) : null, } },
                        interaction: { intersect: false, mode: 'index' },
                    },
                    plugins: [ChartDataLabels],
                });
                window.chartInstances.push(chart);

                let fullAggregatedData = { labels: [], data: [] };

                function updateChartDisplay() {
                    const selectedInterval = parseInt(controlsDiv.querySelector('input[type="radio"]:checked').value, 10);
                    fullAggregatedData = aggregateDataByInterval(chartData, selectedInterval);
                    
                    // Populate time selectors
                    startTimeSelect.innerHTML = '';
                    endTimeSelect.innerHTML = '';
                    fullAggregatedData.labels.forEach((label, index) => {
                        startTimeSelect.add(new Option(label, index));
                        endTimeSelect.add(new Option(label, index));
                    });

                    // Update sliders
                    startSlider.min = 0;
                    startSlider.max = fullAggregatedData.labels.length - 1;
                    endSlider.min = 0;
                    endSlider.max = fullAggregatedData.labels.length - 1;

                    // Set initial/current range to full range
                    const startIndex = 0;
                    const endIndex = fullAggregatedData.labels.length > 0 ? fullAggregatedData.labels.length - 1 : 0;
                    startTimeSelect.value = startIndex;
                    endTimeSelect.value = endIndex;
                    startSlider.value = startIndex;
                    endSlider.value = endIndex;

                    filterAndUpdateChart();
                }

                function filterAndUpdateChart() {
                    let startIndex = parseInt(startSlider.value);
                    let endIndex = parseInt(endSlider.value);

                    if (startIndex > endIndex) [startIndex, endIndex] = [endIndex, startIndex];

                    // Sync dropdowns to sliders
                    startTimeSelect.value = startIndex;
                    endTimeSelect.value = endIndex;

                    // Sync slider range fill
                    const totalSteps = fullAggregatedData.labels.length -1;
                    sliderRange.style.left = totalSteps > 0 ? `${(startIndex / totalSteps) * 100}%` : '0%';
                    sliderRange.style.width = totalSteps > 0 ? `${((endIndex - startIndex) / totalSteps) * 100}%` : '100%';

                    // Update chart data
                    const visibleLabels = fullAggregatedData.labels.slice(startIndex, endIndex + 1);
                    const visibleData = fullAggregatedData.data.slice(startIndex, endIndex + 1);

                    chart.data.labels = visibleLabels;
                    chart.data.datasets[0].data = visibleData;

                    const intervalLabel = intervals.find(i => i.value === parseInt(controlsDiv.querySelector('input[type="radio"]:checked').value)).label;
                    chart.options.scales.x.title.text = `Time Period (${intervalLabel} Granularity)`;

                    // Add padding to Y-axis
                    const maxVisibleValue = Math.max(...visibleData, 0);
                    chart.options.scales.y.max = maxVisibleValue > 0 ? maxVisibleValue * 1.25 : 10;
                    
                    chart.update();
                }

                // Event Listeners
                controlsDiv.addEventListener('change', (e) => {
                    if (e.target.type === 'radio') updateChartDisplay();
                });

                startTimeSelect.addEventListener('change', () => {
                    if (parseInt(startTimeSelect.value) > parseInt(endSlider.value)) {
                        startSlider.value = endTimeSelect.value;
                        endSlider.value = startTimeSelect.value;
                    } else {
                        startSlider.value = startTimeSelect.value;
                    }
                    filterAndUpdateChart();
                });

                endTimeSelect.addEventListener('change', () => {
                     if (parseInt(endTimeSelect.value) < parseInt(startSlider.value)) {
                        endSlider.value = startTimeSelect.value;
                        startSlider.value = endTimeSelect.value;
                    } else {
                        endSlider.value = endTimeSelect.value;
                    }
                    filterAndUpdateChart();
                });

                startSlider.addEventListener('input', filterAndUpdateChart);
                endSlider.addEventListener('input', filterAndUpdateChart);

                downloadButton.addEventListener('click', () => {
                    const dataToExport = fullAggregatedData.labels.map((label, i) => ({
                        'Time Period': label,
                        'Sum of Messages': fullAggregatedData.data[i]
                    }));
                    const worksheet = XLSX.utils.json_to_sheet(dataToExport);
                    const workbook = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(workbook, worksheet, 'Chart Data');
                    XLSX.writeFile(workbook, `group_${groupId}_summary.xlsx`);
                });

                // Initial load
                updateChartDisplay();

            }, 0);

            return section;
        }

        function aggregateDataByInterval(chartData, intervalMinutes) {
            if (!chartData || chartData.length === 0) return { labels: [], data: [] };

            // Find the time range of the data
            const times = chartData.map(d => d.time.getTime());
            if (times.length === 0) return { labels: [], data: [] };
            let minTime = new Date(Math.min(...times));
            let maxTime = new Date(Math.max(...times));

            // Round minTime down to the start of its interval
            const intervalMillis = intervalMinutes * 60 * 1000;
            const roundedMinTime = new Date(Math.floor(minTime.getTime() / intervalMillis) * intervalMillis);

            const aggregated = new Map();
            const labels = [];
            
            // Create all possible time slots from the rounded start to the absolute end time
            let currentSlotTime = new Date(roundedMinTime.getTime());
            while (currentSlotTime <= maxTime) {
                const timeKey = currentSlotTime.getTime();
                aggregated.set(timeKey, 0);

                // Format label with date and time
                const year = currentSlotTime.getFullYear();
                const month = String(currentSlotTime.getMonth() + 1).padStart(2, '0');
                const day = String(currentSlotTime.getDate()).padStart(2, '0');
                const hour = String(currentSlotTime.getHours()).padStart(2, '0');
                const minute = String(currentSlotTime.getMinutes()).padStart(2, '0');
                labels.push(`${year}-${month}-${day} ${hour}:${minute}`);
                
                currentSlotTime = new Date(currentSlotTime.getTime() + intervalMillis);
            }

            // Populate the time slots with data
            chartData.forEach(item => {
                const itemTimeKey = Math.floor(item.time.getTime() / intervalMillis) * intervalMillis;
                if (aggregated.has(itemTimeKey)) {
                    aggregated.set(itemTimeKey, aggregated.get(itemTimeKey) + item.value);
                }
            });
            
            // Convert the map of aggregated data to a simple array
            const data = Array.from(aggregated.values());

            return { labels, data };
        }
        
        function createTableForGroup(tableData) {
            const tableContainer = document.createElement('div');
            tableContainer.className = "overflow-x-auto";
            const table = document.createElement('table');
            table.className = 'min-w-full bg-white border border-gray-200 rounded-lg shadow-sm';
            
            const thead = table.createTHead();
            thead.className = 'bg-gray-100';
            const headerRow = thead.insertRow();
            ['Create Time', 'Sum of successfully sent messages'].forEach(text => {
                const th = document.createElement('th');
                th.textContent = text;
                th.className = 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider';
                headerRow.appendChild(th);
            });

            const tbody = table.createTBody();
            tbody.className = 'divide-y divide-gray-200';
            Object.keys(tableData).sort().forEach(time => {
                const row = tbody.insertRow();
                row.insertCell().textContent = time;
                row.cells[0].className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-700';
                row.insertCell().textContent = tableData[time];
                row.cells[1].className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-700';
            });
            
            tableContainer.appendChild(table);
            return tableContainer;
        }
        
        function addTabEventListeners() {
            // Main tab switching logic
            const mainButtons = document.querySelectorAll('.tab-button');
            const mainContents = document.querySelectorAll('.tab-content');
            mainButtons.forEach(button => {
                button.addEventListener('click', () => {
                    mainButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    mainContents.forEach(content => content.classList.add('hidden'));
                    const targetContent = document.getElementById(button.dataset.target);
                    if(targetContent) targetContent.classList.remove('hidden');
                });
            });
        }
        
        function displayMessage(text, type) {
            const colors = {
                red: 'bg-red-100 border-red-400 text-red-700', 
                green: 'bg-green-100 border-green-400 text-green-700',
                blue: 'bg-blue-100 border-blue-400 text-blue-700', 
                yellow: 'bg-yellow-100 border-yellow-400 text-yellow-700'
            };
            messageDiv.innerHTML = `<div class="border rounded p-4 ${colors[type] || ''}" role="alert">${text}</div>`;
        }

        function clearContent() {
            window.chartInstances.forEach(chart => chart.destroy());
            window.chartInstances = [];
            outputDiv.innerHTML = '';
            messageDiv.innerHTML = '';
            tabButtonsDiv.innerHTML = '';
        }
    </script>

</body>
</html>

